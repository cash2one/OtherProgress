// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: login.proto

#ifndef PROTOBUF_login_2eproto__INCLUDED
#define PROTOBUF_login_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "build.pb.h"
#include "kittygarden.pb.h"
#include "produceitem.pb.h"
#include "usecardbuild.pb.h"
#include "dress.pb.h"
#include "enterkitty.pb.h"
#include "common.pb.h"
#include "event.pb.h"
#include "burstevent.pb.h"
// @@protoc_insertion_point(includes)

namespace HelloKittyMsgData {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_login_2eproto();
void protobuf_AssignDesc_login_2eproto();
void protobuf_ShutdownFile_login_2eproto();

class ReqVersion;
class AckVersion;
class ReqLogin;
class AckLoginFailReturn;
class AckLoginSuccessReturn;
class ReqLoginGateway;
class AckGameTime;
class UserBaseInfo;
class AckUserInfo;
class ReqCreateRole;
class ReqOpReceiveWorldChatCmd;
class AckNoticeClient;
class AckFlushUserInfo;
class ReqLogout;

enum PhoneType {
  Android = 0,
  Iphone = 1
};
bool PhoneType_IsValid(int value);
const PhoneType PhoneType_MIN = Android;
const PhoneType PhoneType_MAX = Iphone;
const int PhoneType_ARRAYSIZE = PhoneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PhoneType_descriptor();
inline const ::std::string& PhoneType_Name(PhoneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PhoneType_descriptor(), value);
}
inline bool PhoneType_Parse(
    const ::std::string& name, PhoneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PhoneType>(
    PhoneType_descriptor(), name, value);
}
enum NetType {
  Tele = 0,
  NetCom = 1
};
bool NetType_IsValid(int value);
const NetType NetType_MIN = Tele;
const NetType NetType_MAX = NetCom;
const int NetType_ARRAYSIZE = NetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetType_descriptor();
inline const ::std::string& NetType_Name(NetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetType_descriptor(), value);
}
inline bool NetType_Parse(
    const ::std::string& name, NetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetType>(
    NetType_descriptor(), name, value);
}
enum UserPlateType {
  Tencent = 0,
  Baidu = 1,
  Qihoo = 2,
  Other = 3
};
bool UserPlateType_IsValid(int value);
const UserPlateType UserPlateType_MIN = Tencent;
const UserPlateType UserPlateType_MAX = Other;
const int UserPlateType_ARRAYSIZE = UserPlateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserPlateType_descriptor();
inline const ::std::string& UserPlateType_Name(UserPlateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserPlateType_descriptor(), value);
}
inline bool UserPlateType_Parse(
    const ::std::string& name, UserPlateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserPlateType>(
    UserPlateType_descriptor(), name, value);
}
enum LoginFailReason {
  AccountOdd = 0,
  VersionError = 1,
  NormalMain = 2,
  GatewayNotOpen = 3,
  UserFull = 4,
  SendZoneError = 5,
  TimeOut = 6,
  UuidError = 7,
  NameIllega = 8,
  NameAgain = 9,
  NotRole = 10
};
bool LoginFailReason_IsValid(int value);
const LoginFailReason LoginFailReason_MIN = AccountOdd;
const LoginFailReason LoginFailReason_MAX = NotRole;
const int LoginFailReason_ARRAYSIZE = LoginFailReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginFailReason_descriptor();
inline const ::std::string& LoginFailReason_Name(LoginFailReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginFailReason_descriptor(), value);
}
inline bool LoginFailReason_Parse(
    const ::std::string& name, LoginFailReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginFailReason>(
    LoginFailReason_descriptor(), name, value);
}
enum LoginRetType {
  Normal = 0,
  Kick = 1
};
bool LoginRetType_IsValid(int value);
const LoginRetType LoginRetType_MIN = Normal;
const LoginRetType LoginRetType_MAX = Kick;
const int LoginRetType_ARRAYSIZE = LoginRetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginRetType_descriptor();
inline const ::std::string& LoginRetType_Name(LoginRetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginRetType_descriptor(), value);
}
inline bool LoginRetType_Parse(
    const ::std::string& name, LoginRetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginRetType>(
    LoginRetType_descriptor(), name, value);
}
enum SexType {
  Male = 0,
  Female = 1
};
bool SexType_IsValid(int value);
const SexType SexType_MIN = Male;
const SexType SexType_MAX = Female;
const int SexType_ARRAYSIZE = SexType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SexType_descriptor();
inline const ::std::string& SexType_Name(SexType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SexType_descriptor(), value);
}
inline bool SexType_Parse(
    const ::std::string& name, SexType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SexType>(
    SexType_descriptor(), name, value);
}
enum SwitchType {
  Open = 0,
  Close = 1
};
bool SwitchType_IsValid(int value);
const SwitchType SwitchType_MIN = Open;
const SwitchType SwitchType_MAX = Close;
const int SwitchType_ARRAYSIZE = SwitchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SwitchType_descriptor();
inline const ::std::string& SwitchType_Name(SwitchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SwitchType_descriptor(), value);
}
inline bool SwitchType_Parse(
    const ::std::string& name, SwitchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SwitchType>(
    SwitchType_descriptor(), name, value);
}
enum NoticeType {
  Notice_Kick_Out = 0
};
bool NoticeType_IsValid(int value);
const NoticeType NoticeType_MIN = Notice_Kick_Out;
const NoticeType NoticeType_MAX = Notice_Kick_Out;
const int NoticeType_ARRAYSIZE = NoticeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NoticeType_descriptor();
inline const ::std::string& NoticeType_Name(NoticeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NoticeType_descriptor(), value);
}
inline bool NoticeType_Parse(
    const ::std::string& name, NoticeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NoticeType>(
    NoticeType_descriptor(), name, value);
}
// ===================================================================

class ReqVersion : public ::google::protobuf::Message {
 public:
  ReqVersion();
  virtual ~ReqVersion();

  ReqVersion(const ReqVersion& from);

  inline ReqVersion& operator=(const ReqVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqVersion& default_instance();

  void Swap(ReqVersion* other);

  // implements Message ----------------------------------------------

  ReqVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqVersion& from);
  void MergeFrom(const ReqVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 clientVersion = 1;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 clientversion() const;
  inline void set_clientversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ReqVersion)
 private:
  inline void set_has_clientversion();
  inline void clear_has_clientversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ReqVersion* default_instance_;
};
// -------------------------------------------------------------------

class AckVersion : public ::google::protobuf::Message {
 public:
  AckVersion();
  virtual ~AckVersion();

  AckVersion(const AckVersion& from);

  inline AckVersion& operator=(const AckVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckVersion& default_instance();

  void Swap(AckVersion* other);

  // implements Message ----------------------------------------------

  AckVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckVersion& from);
  void MergeFrom(const AckVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.AckVersion)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static AckVersion* default_instance_;
};
// -------------------------------------------------------------------

class ReqLogin : public ::google::protobuf::Message {
 public:
  ReqLogin();
  virtual ~ReqLogin();

  ReqLogin(const ReqLogin& from);

  inline ReqLogin& operator=(const ReqLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogin& default_instance();

  void Swap(ReqLogin* other);

  // implements Message ----------------------------------------------

  ReqLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLogin& from);
  void MergeFrom(const ReqLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HelloKittyMsgData.PhoneType phoneType = 1;
  inline bool has_phonetype() const;
  inline void clear_phonetype();
  static const int kPhoneTypeFieldNumber = 1;
  inline ::HelloKittyMsgData::PhoneType phonetype() const;
  inline void set_phonetype(::HelloKittyMsgData::PhoneType value);

  // required string phoneUuid = 2;
  inline bool has_phoneuuid() const;
  inline void clear_phoneuuid();
  static const int kPhoneUuidFieldNumber = 2;
  inline const ::std::string& phoneuuid() const;
  inline void set_phoneuuid(const ::std::string& value);
  inline void set_phoneuuid(const char* value);
  inline void set_phoneuuid(const char* value, size_t size);
  inline ::std::string* mutable_phoneuuid();
  inline ::std::string* release_phoneuuid();
  inline void set_allocated_phoneuuid(::std::string* phoneuuid);

  // required uint32 gameZone = 3;
  inline bool has_gamezone() const;
  inline void clear_gamezone();
  static const int kGameZoneFieldNumber = 3;
  inline ::google::protobuf::uint32 gamezone() const;
  inline void set_gamezone(::google::protobuf::uint32 value);

  // required string account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required .HelloKittyMsgData.NetType netType = 5;
  inline bool has_nettype() const;
  inline void clear_nettype();
  static const int kNetTypeFieldNumber = 5;
  inline ::HelloKittyMsgData::NetType nettype() const;
  inline void set_nettype(::HelloKittyMsgData::NetType value);

  // required .HelloKittyMsgData.UserPlateType usertype = 6;
  inline bool has_usertype() const;
  inline void clear_usertype();
  static const int kUsertypeFieldNumber = 6;
  inline ::HelloKittyMsgData::UserPlateType usertype() const;
  inline void set_usertype(::HelloKittyMsgData::UserPlateType value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ReqLogin)
 private:
  inline void set_has_phonetype();
  inline void clear_has_phonetype();
  inline void set_has_phoneuuid();
  inline void clear_has_phoneuuid();
  inline void set_has_gamezone();
  inline void clear_has_gamezone();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_nettype();
  inline void clear_has_nettype();
  inline void set_has_usertype();
  inline void clear_has_usertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* phoneuuid_;
  int phonetype_;
  ::google::protobuf::uint32 gamezone_;
  ::std::string* account_;
  int nettype_;
  int usertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ReqLogin* default_instance_;
};
// -------------------------------------------------------------------

class AckLoginFailReturn : public ::google::protobuf::Message {
 public:
  AckLoginFailReturn();
  virtual ~AckLoginFailReturn();

  AckLoginFailReturn(const AckLoginFailReturn& from);

  inline AckLoginFailReturn& operator=(const AckLoginFailReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLoginFailReturn& default_instance();

  void Swap(AckLoginFailReturn* other);

  // implements Message ----------------------------------------------

  AckLoginFailReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLoginFailReturn& from);
  void MergeFrom(const AckLoginFailReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HelloKittyMsgData.LoginFailReason failReason = 1;
  inline bool has_failreason() const;
  inline void clear_failreason();
  static const int kFailReasonFieldNumber = 1;
  inline ::HelloKittyMsgData::LoginFailReason failreason() const;
  inline void set_failreason(::HelloKittyMsgData::LoginFailReason value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.AckLoginFailReturn)
 private:
  inline void set_has_failreason();
  inline void clear_has_failreason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int failreason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static AckLoginFailReturn* default_instance_;
};
// -------------------------------------------------------------------

class AckLoginSuccessReturn : public ::google::protobuf::Message {
 public:
  AckLoginSuccessReturn();
  virtual ~AckLoginSuccessReturn();

  AckLoginSuccessReturn(const AckLoginSuccessReturn& from);

  inline AckLoginSuccessReturn& operator=(const AckLoginSuccessReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckLoginSuccessReturn& default_instance();

  void Swap(AckLoginSuccessReturn* other);

  // implements Message ----------------------------------------------

  AckLoginSuccessReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckLoginSuccessReturn& from);
  void MergeFrom(const AckLoginSuccessReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 loginTempID = 1;
  inline bool has_logintempid() const;
  inline void clear_logintempid();
  static const int kLoginTempIDFieldNumber = 1;
  inline ::google::protobuf::uint32 logintempid() const;
  inline void set_logintempid(::google::protobuf::uint32 value);

  // required string gatewayIP = 2;
  inline bool has_gatewayip() const;
  inline void clear_gatewayip();
  static const int kGatewayIPFieldNumber = 2;
  inline const ::std::string& gatewayip() const;
  inline void set_gatewayip(const ::std::string& value);
  inline void set_gatewayip(const char* value);
  inline void set_gatewayip(const char* value, size_t size);
  inline ::std::string* mutable_gatewayip();
  inline ::std::string* release_gatewayip();
  inline void set_allocated_gatewayip(::std::string* gatewayip);

  // required uint32 gatewayPort = 3;
  inline bool has_gatewayport() const;
  inline void clear_gatewayport();
  static const int kGatewayPortFieldNumber = 3;
  inline ::google::protobuf::uint32 gatewayport() const;
  inline void set_gatewayport(::google::protobuf::uint32 value);

  // repeated uint32 keyArr = 4;
  inline int keyarr_size() const;
  inline void clear_keyarr();
  static const int kKeyArrFieldNumber = 4;
  inline ::google::protobuf::uint32 keyarr(int index) const;
  inline void set_keyarr(int index, ::google::protobuf::uint32 value);
  inline void add_keyarr(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      keyarr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_keyarr();

  // required .HelloKittyMsgData.LoginRetType loginRet = 5;
  inline bool has_loginret() const;
  inline void clear_loginret();
  static const int kLoginRetFieldNumber = 5;
  inline ::HelloKittyMsgData::LoginRetType loginret() const;
  inline void set_loginret(::HelloKittyMsgData::LoginRetType value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.AckLoginSuccessReturn)
 private:
  inline void set_has_logintempid();
  inline void clear_has_logintempid();
  inline void set_has_gatewayip();
  inline void clear_has_gatewayip();
  inline void set_has_gatewayport();
  inline void clear_has_gatewayport();
  inline void set_has_loginret();
  inline void clear_has_loginret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gatewayip_;
  ::google::protobuf::uint32 logintempid_;
  ::google::protobuf::uint32 gatewayport_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > keyarr_;
  int loginret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static AckLoginSuccessReturn* default_instance_;
};
// -------------------------------------------------------------------

class ReqLoginGateway : public ::google::protobuf::Message {
 public:
  ReqLoginGateway();
  virtual ~ReqLoginGateway();

  ReqLoginGateway(const ReqLoginGateway& from);

  inline ReqLoginGateway& operator=(const ReqLoginGateway& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLoginGateway& default_instance();

  void Swap(ReqLoginGateway* other);

  // implements Message ----------------------------------------------

  ReqLoginGateway* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLoginGateway& from);
  void MergeFrom(const ReqLoginGateway& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required .HelloKittyMsgData.UserPlateType usertype = 2;
  inline bool has_usertype() const;
  inline void clear_usertype();
  static const int kUsertypeFieldNumber = 2;
  inline ::HelloKittyMsgData::UserPlateType usertype() const;
  inline void set_usertype(::HelloKittyMsgData::UserPlateType value);

  // required .HelloKittyMsgData.PhoneType phoneType = 3;
  inline bool has_phonetype() const;
  inline void clear_phonetype();
  static const int kPhoneTypeFieldNumber = 3;
  inline ::HelloKittyMsgData::PhoneType phonetype() const;
  inline void set_phonetype(::HelloKittyMsgData::PhoneType value);

  // required string phoneUuid = 4;
  inline bool has_phoneuuid() const;
  inline void clear_phoneuuid();
  static const int kPhoneUuidFieldNumber = 4;
  inline const ::std::string& phoneuuid() const;
  inline void set_phoneuuid(const ::std::string& value);
  inline void set_phoneuuid(const char* value);
  inline void set_phoneuuid(const char* value, size_t size);
  inline ::std::string* mutable_phoneuuid();
  inline ::std::string* release_phoneuuid();
  inline void set_allocated_phoneuuid(::std::string* phoneuuid);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ReqLoginGateway)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_usertype();
  inline void clear_has_usertype();
  inline void set_has_phonetype();
  inline void clear_has_phonetype();
  inline void set_has_phoneuuid();
  inline void clear_has_phoneuuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int usertype_;
  int phonetype_;
  ::std::string* phoneuuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ReqLoginGateway* default_instance_;
};
// -------------------------------------------------------------------

class AckGameTime : public ::google::protobuf::Message {
 public:
  AckGameTime();
  virtual ~AckGameTime();

  AckGameTime(const AckGameTime& from);

  inline AckGameTime& operator=(const AckGameTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckGameTime& default_instance();

  void Swap(AckGameTime* other);

  // implements Message ----------------------------------------------

  AckGameTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckGameTime& from);
  void MergeFrom(const AckGameTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gameTime = 1;
  inline bool has_gametime() const;
  inline void clear_gametime();
  static const int kGameTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 gametime() const;
  inline void set_gametime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.AckGameTime)
 private:
  inline void set_has_gametime();
  inline void clear_has_gametime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gametime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static AckGameTime* default_instance_;
};
// -------------------------------------------------------------------

class UserBaseInfo : public ::google::protobuf::Message {
 public:
  UserBaseInfo();
  virtual ~UserBaseInfo();

  UserBaseInfo(const UserBaseInfo& from);

  inline UserBaseInfo& operator=(const UserBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserBaseInfo& default_instance();

  void Swap(UserBaseInfo* other);

  // implements Message ----------------------------------------------

  UserBaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserBaseInfo& from);
  void MergeFrom(const UserBaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 charId = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint64 charid() const;
  inline void set_charid(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .HelloKittyMsgData.SexType sex = 3;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline ::HelloKittyMsgData::SexType sex() const;
  inline void set_sex(::HelloKittyMsgData::SexType value);

  // required uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint64 exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // required uint64 gold = 6;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 6;
  inline ::google::protobuf::uint64 gold() const;
  inline void set_gold(::google::protobuf::uint64 value);

  // required uint64 gem = 7;
  inline bool has_gem() const;
  inline void clear_gem();
  static const int kGemFieldNumber = 7;
  inline ::google::protobuf::uint64 gem() const;
  inline void set_gem(::google::protobuf::uint64 value);

  // required uint32 workernum = 8;
  inline bool has_workernum() const;
  inline void clear_workernum();
  static const int kWorkernumFieldNumber = 8;
  inline ::google::protobuf::uint32 workernum() const;
  inline void set_workernum(::google::protobuf::uint32 value);

  // required uint32 friendval = 9;
  inline bool has_friendval() const;
  inline void clear_friendval();
  static const int kFriendvalFieldNumber = 9;
  inline ::google::protobuf::uint32 friendval() const;
  inline void set_friendval(::google::protobuf::uint32 value);

  // required uint32 happyval = 10;
  inline bool has_happyval() const;
  inline void clear_happyval();
  static const int kHappyvalFieldNumber = 10;
  inline ::google::protobuf::uint32 happyval() const;
  inline void set_happyval(::google::protobuf::uint32 value);

  // required uint32 randtoy = 11;
  inline bool has_randtoy() const;
  inline void clear_randtoy();
  static const int kRandtoyFieldNumber = 11;
  inline ::google::protobuf::uint32 randtoy() const;
  inline void set_randtoy(::google::protobuf::uint32 value);

  // required uint32 itemwarehousecap = 12;
  inline bool has_itemwarehousecap() const;
  inline void clear_itemwarehousecap();
  static const int kItemwarehousecapFieldNumber = 12;
  inline ::google::protobuf::uint32 itemwarehousecap() const;
  inline void set_itemwarehousecap(::google::protobuf::uint32 value);

  // required uint32 sweetval = 13;
  inline bool has_sweetval() const;
  inline void clear_sweetval();
  static const int kSweetvalFieldNumber = 13;
  inline ::google::protobuf::uint32 sweetval() const;
  inline void set_sweetval(::google::protobuf::uint32 value);

  // required uint32 carnival = 14;
  inline bool has_carnival() const;
  inline void clear_carnival();
  static const int kCarnivalFieldNumber = 14;
  inline ::google::protobuf::uint32 carnival() const;
  inline void set_carnival(::google::protobuf::uint32 value);

  // required .HelloKittyMsgData.DressData dress = 15;
  inline bool has_dress() const;
  inline void clear_dress();
  static const int kDressFieldNumber = 15;
  inline const ::HelloKittyMsgData::DressData& dress() const;
  inline ::HelloKittyMsgData::DressData* mutable_dress();
  inline ::HelloKittyMsgData::DressData* release_dress();
  inline void set_allocated_dress(::HelloKittyMsgData::DressData* dress);

  // repeated .HelloKittyMsgData.BuildBase buildinfo = 16;
  inline int buildinfo_size() const;
  inline void clear_buildinfo();
  static const int kBuildinfoFieldNumber = 16;
  inline const ::HelloKittyMsgData::BuildBase& buildinfo(int index) const;
  inline ::HelloKittyMsgData::BuildBase* mutable_buildinfo(int index);
  inline ::HelloKittyMsgData::BuildBase* add_buildinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BuildBase >&
      buildinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BuildBase >*
      mutable_buildinfo();

  // required .HelloKittyMsgData.KittyGarden kittygarden = 17;
  inline bool has_kittygarden() const;
  inline void clear_kittygarden();
  static const int kKittygardenFieldNumber = 17;
  inline const ::HelloKittyMsgData::KittyGarden& kittygarden() const;
  inline ::HelloKittyMsgData::KittyGarden* mutable_kittygarden();
  inline ::HelloKittyMsgData::KittyGarden* release_kittygarden();
  inline void set_allocated_kittygarden(::HelloKittyMsgData::KittyGarden* kittygarden);

  // repeated .HelloKittyMsgData.BuildProduce produce = 18;
  inline int produce_size() const;
  inline void clear_produce();
  static const int kProduceFieldNumber = 18;
  inline const ::HelloKittyMsgData::BuildProduce& produce(int index) const;
  inline ::HelloKittyMsgData::BuildProduce* mutable_produce(int index);
  inline ::HelloKittyMsgData::BuildProduce* add_produce();
  inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BuildProduce >&
      produce() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BuildProduce >*
      mutable_produce();

  // repeated .HelloKittyMsgData.StoreFunctionCell produceitem = 19;
  inline int produceitem_size() const;
  inline void clear_produceitem();
  static const int kProduceitemFieldNumber = 19;
  inline const ::HelloKittyMsgData::StoreFunctionCell& produceitem(int index) const;
  inline ::HelloKittyMsgData::StoreFunctionCell* mutable_produceitem(int index);
  inline ::HelloKittyMsgData::StoreFunctionCell* add_produceitem();
  inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::StoreFunctionCell >&
      produceitem() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::StoreFunctionCell >*
      mutable_produceitem();

  // repeated .HelloKittyMsgData.BufferInfo bufferinfo = 20;
  inline int bufferinfo_size() const;
  inline void clear_bufferinfo();
  static const int kBufferinfoFieldNumber = 20;
  inline const ::HelloKittyMsgData::BufferInfo& bufferinfo(int index) const;
  inline ::HelloKittyMsgData::BufferInfo* mutable_bufferinfo(int index);
  inline ::HelloKittyMsgData::BufferInfo* add_bufferinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BufferInfo >&
      bufferinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BufferInfo >*
      mutable_bufferinfo();

  // repeated .HelloKittyMsgData.UseCardInfo usecard = 21;
  inline int usecard_size() const;
  inline void clear_usecard();
  static const int kUsecardFieldNumber = 21;
  inline const ::HelloKittyMsgData::UseCardInfo& usecard(int index) const;
  inline ::HelloKittyMsgData::UseCardInfo* mutable_usecard(int index);
  inline ::HelloKittyMsgData::UseCardInfo* add_usecard();
  inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::UseCardInfo >&
      usecard() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::UseCardInfo >*
      mutable_usecard();

  // repeated .HelloKittyMsgData.BufferData externbuffer = 22;
  inline int externbuffer_size() const;
  inline void clear_externbuffer();
  static const int kExternbufferFieldNumber = 22;
  inline const ::HelloKittyMsgData::BufferData& externbuffer(int index) const;
  inline ::HelloKittyMsgData::BufferData* mutable_externbuffer(int index);
  inline ::HelloKittyMsgData::BufferData* add_externbuffer();
  inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BufferData >&
      externbuffer() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BufferData >*
      mutable_externbuffer();

  // repeated .HelloKittyMsgData.RubbishData rubbish = 23;
  inline int rubbish_size() const;
  inline void clear_rubbish();
  static const int kRubbishFieldNumber = 23;
  inline const ::HelloKittyMsgData::RubbishData& rubbish(int index) const;
  inline ::HelloKittyMsgData::RubbishData* mutable_rubbish(int index);
  inline ::HelloKittyMsgData::RubbishData* add_rubbish();
  inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::RubbishData >&
      rubbish() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::RubbishData >*
      mutable_rubbish();

  // required .HelloKittyMsgData.Evententer eventinit = 24;
  inline bool has_eventinit() const;
  inline void clear_eventinit();
  static const int kEventinitFieldNumber = 24;
  inline const ::HelloKittyMsgData::Evententer& eventinit() const;
  inline ::HelloKittyMsgData::Evententer* mutable_eventinit();
  inline ::HelloKittyMsgData::Evententer* release_eventinit();
  inline void set_allocated_eventinit(::HelloKittyMsgData::Evententer* eventinit);

  // repeated .HelloKittyMsgData.BurstEvent burstevent = 25;
  inline int burstevent_size() const;
  inline void clear_burstevent();
  static const int kBursteventFieldNumber = 25;
  inline const ::HelloKittyMsgData::BurstEvent& burstevent(int index) const;
  inline ::HelloKittyMsgData::BurstEvent* mutable_burstevent(int index);
  inline ::HelloKittyMsgData::BurstEvent* add_burstevent();
  inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BurstEvent >&
      burstevent() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BurstEvent >*
      mutable_burstevent();

  // optional uint64 familyid = 26 [default = 0];
  inline bool has_familyid() const;
  inline void clear_familyid();
  static const int kFamilyidFieldNumber = 26;
  inline ::google::protobuf::uint64 familyid() const;
  inline void set_familyid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.UserBaseInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_gem();
  inline void clear_has_gem();
  inline void set_has_workernum();
  inline void clear_has_workernum();
  inline void set_has_friendval();
  inline void clear_has_friendval();
  inline void set_has_happyval();
  inline void clear_has_happyval();
  inline void set_has_randtoy();
  inline void clear_has_randtoy();
  inline void set_has_itemwarehousecap();
  inline void clear_has_itemwarehousecap();
  inline void set_has_sweetval();
  inline void clear_has_sweetval();
  inline void set_has_carnival();
  inline void clear_has_carnival();
  inline void set_has_dress();
  inline void clear_has_dress();
  inline void set_has_kittygarden();
  inline void clear_has_kittygarden();
  inline void set_has_eventinit();
  inline void clear_has_eventinit();
  inline void set_has_familyid();
  inline void clear_has_familyid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 charid_;
  ::std::string* name_;
  int sex_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint64 exp_;
  ::google::protobuf::uint64 gold_;
  ::google::protobuf::uint64 gem_;
  ::google::protobuf::uint32 workernum_;
  ::google::protobuf::uint32 friendval_;
  ::google::protobuf::uint32 happyval_;
  ::google::protobuf::uint32 randtoy_;
  ::google::protobuf::uint32 itemwarehousecap_;
  ::google::protobuf::uint32 sweetval_;
  ::HelloKittyMsgData::DressData* dress_;
  ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BuildBase > buildinfo_;
  ::HelloKittyMsgData::KittyGarden* kittygarden_;
  ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BuildProduce > produce_;
  ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::StoreFunctionCell > produceitem_;
  ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BufferInfo > bufferinfo_;
  ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::UseCardInfo > usecard_;
  ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BufferData > externbuffer_;
  ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::RubbishData > rubbish_;
  ::HelloKittyMsgData::Evententer* eventinit_;
  ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BurstEvent > burstevent_;
  ::google::protobuf::uint64 familyid_;
  ::google::protobuf::uint32 carnival_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static UserBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class AckUserInfo : public ::google::protobuf::Message {
 public:
  AckUserInfo();
  virtual ~AckUserInfo();

  AckUserInfo(const AckUserInfo& from);

  inline AckUserInfo& operator=(const AckUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUserInfo& default_instance();

  void Swap(AckUserInfo* other);

  // implements Message ----------------------------------------------

  AckUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUserInfo& from);
  void MergeFrom(const AckUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool hasUser = 1;
  inline bool has_hasuser() const;
  inline void clear_hasuser();
  static const int kHasUserFieldNumber = 1;
  inline bool hasuser() const;
  inline void set_hasuser(bool value);

  // required .HelloKittyMsgData.UserBaseInfo userBase = 2;
  inline bool has_userbase() const;
  inline void clear_userbase();
  static const int kUserBaseFieldNumber = 2;
  inline const ::HelloKittyMsgData::UserBaseInfo& userbase() const;
  inline ::HelloKittyMsgData::UserBaseInfo* mutable_userbase();
  inline ::HelloKittyMsgData::UserBaseInfo* release_userbase();
  inline void set_allocated_userbase(::HelloKittyMsgData::UserBaseInfo* userbase);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.AckUserInfo)
 private:
  inline void set_has_hasuser();
  inline void clear_has_hasuser();
  inline void set_has_userbase();
  inline void clear_has_userbase();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::HelloKittyMsgData::UserBaseInfo* userbase_;
  bool hasuser_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static AckUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqCreateRole : public ::google::protobuf::Message {
 public:
  ReqCreateRole();
  virtual ~ReqCreateRole();

  ReqCreateRole(const ReqCreateRole& from);

  inline ReqCreateRole& operator=(const ReqCreateRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqCreateRole& default_instance();

  void Swap(ReqCreateRole* other);

  // implements Message ----------------------------------------------

  ReqCreateRole* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqCreateRole& from);
  void MergeFrom(const ReqCreateRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .HelloKittyMsgData.SexType sex = 2;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 2;
  inline ::HelloKittyMsgData::SexType sex() const;
  inline void set_sex(::HelloKittyMsgData::SexType value);

  // required uint32 heroId = 3;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroIdFieldNumber = 3;
  inline ::google::protobuf::uint32 heroid() const;
  inline void set_heroid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ReqCreateRole)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_heroid();
  inline void clear_has_heroid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  int sex_;
  ::google::protobuf::uint32 heroid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ReqCreateRole* default_instance_;
};
// -------------------------------------------------------------------

class ReqOpReceiveWorldChatCmd : public ::google::protobuf::Message {
 public:
  ReqOpReceiveWorldChatCmd();
  virtual ~ReqOpReceiveWorldChatCmd();

  ReqOpReceiveWorldChatCmd(const ReqOpReceiveWorldChatCmd& from);

  inline ReqOpReceiveWorldChatCmd& operator=(const ReqOpReceiveWorldChatCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqOpReceiveWorldChatCmd& default_instance();

  void Swap(ReqOpReceiveWorldChatCmd* other);

  // implements Message ----------------------------------------------

  ReqOpReceiveWorldChatCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqOpReceiveWorldChatCmd& from);
  void MergeFrom(const ReqOpReceiveWorldChatCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HelloKittyMsgData.SwitchType switchFlg = 1;
  inline bool has_switchflg() const;
  inline void clear_switchflg();
  static const int kSwitchFlgFieldNumber = 1;
  inline ::HelloKittyMsgData::SwitchType switchflg() const;
  inline void set_switchflg(::HelloKittyMsgData::SwitchType value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ReqOpReceiveWorldChatCmd)
 private:
  inline void set_has_switchflg();
  inline void clear_has_switchflg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int switchflg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ReqOpReceiveWorldChatCmd* default_instance_;
};
// -------------------------------------------------------------------

class AckNoticeClient : public ::google::protobuf::Message {
 public:
  AckNoticeClient();
  virtual ~AckNoticeClient();

  AckNoticeClient(const AckNoticeClient& from);

  inline AckNoticeClient& operator=(const AckNoticeClient& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckNoticeClient& default_instance();

  void Swap(AckNoticeClient* other);

  // implements Message ----------------------------------------------

  AckNoticeClient* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckNoticeClient& from);
  void MergeFrom(const AckNoticeClient& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HelloKittyMsgData.NoticeType noticeType = 1;
  inline bool has_noticetype() const;
  inline void clear_noticetype();
  static const int kNoticeTypeFieldNumber = 1;
  inline ::HelloKittyMsgData::NoticeType noticetype() const;
  inline void set_noticetype(::HelloKittyMsgData::NoticeType value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.AckNoticeClient)
 private:
  inline void set_has_noticetype();
  inline void clear_has_noticetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int noticetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static AckNoticeClient* default_instance_;
};
// -------------------------------------------------------------------

class AckFlushUserInfo : public ::google::protobuf::Message {
 public:
  AckFlushUserInfo();
  virtual ~AckFlushUserInfo();

  AckFlushUserInfo(const AckFlushUserInfo& from);

  inline AckFlushUserInfo& operator=(const AckFlushUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckFlushUserInfo& default_instance();

  void Swap(AckFlushUserInfo* other);

  // implements Message ----------------------------------------------

  AckFlushUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckFlushUserInfo& from);
  void MergeFrom(const AckFlushUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HelloKittyMsgData.UserBaseInfo userBase = 1;
  inline bool has_userbase() const;
  inline void clear_userbase();
  static const int kUserBaseFieldNumber = 1;
  inline const ::HelloKittyMsgData::UserBaseInfo& userbase() const;
  inline ::HelloKittyMsgData::UserBaseInfo* mutable_userbase();
  inline ::HelloKittyMsgData::UserBaseInfo* release_userbase();
  inline void set_allocated_userbase(::HelloKittyMsgData::UserBaseInfo* userbase);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.AckFlushUserInfo)
 private:
  inline void set_has_userbase();
  inline void clear_has_userbase();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::HelloKittyMsgData::UserBaseInfo* userbase_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static AckFlushUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqLogout : public ::google::protobuf::Message {
 public:
  ReqLogout();
  virtual ~ReqLogout();

  ReqLogout(const ReqLogout& from);

  inline ReqLogout& operator=(const ReqLogout& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqLogout& default_instance();

  void Swap(ReqLogout* other);

  // implements Message ----------------------------------------------

  ReqLogout* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqLogout& from);
  void MergeFrom(const ReqLogout& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ReqLogout)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ReqLogout* default_instance_;
};
// ===================================================================


// ===================================================================

// ReqVersion

// required uint32 clientVersion = 1;
inline bool ReqVersion::has_clientversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqVersion::set_has_clientversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqVersion::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqVersion::clear_clientversion() {
  clientversion_ = 0u;
  clear_has_clientversion();
}
inline ::google::protobuf::uint32 ReqVersion::clientversion() const {
  return clientversion_;
}
inline void ReqVersion::set_clientversion(::google::protobuf::uint32 value) {
  set_has_clientversion();
  clientversion_ = value;
}

// -------------------------------------------------------------------

// AckVersion

// required uint32 version = 1;
inline bool AckVersion::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckVersion::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckVersion::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckVersion::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 AckVersion::version() const {
  return version_;
}
inline void AckVersion::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// ReqLogin

// required .HelloKittyMsgData.PhoneType phoneType = 1;
inline bool ReqLogin::has_phonetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLogin::set_has_phonetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLogin::clear_has_phonetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLogin::clear_phonetype() {
  phonetype_ = 0;
  clear_has_phonetype();
}
inline ::HelloKittyMsgData::PhoneType ReqLogin::phonetype() const {
  return static_cast< ::HelloKittyMsgData::PhoneType >(phonetype_);
}
inline void ReqLogin::set_phonetype(::HelloKittyMsgData::PhoneType value) {
  assert(::HelloKittyMsgData::PhoneType_IsValid(value));
  set_has_phonetype();
  phonetype_ = value;
}

// required string phoneUuid = 2;
inline bool ReqLogin::has_phoneuuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLogin::set_has_phoneuuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLogin::clear_has_phoneuuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLogin::clear_phoneuuid() {
  if (phoneuuid_ != &::google::protobuf::internal::kEmptyString) {
    phoneuuid_->clear();
  }
  clear_has_phoneuuid();
}
inline const ::std::string& ReqLogin::phoneuuid() const {
  return *phoneuuid_;
}
inline void ReqLogin::set_phoneuuid(const ::std::string& value) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(value);
}
inline void ReqLogin::set_phoneuuid(const char* value) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(value);
}
inline void ReqLogin::set_phoneuuid(const char* value, size_t size) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_phoneuuid() {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  return phoneuuid_;
}
inline ::std::string* ReqLogin::release_phoneuuid() {
  clear_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phoneuuid_;
    phoneuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_phoneuuid(::std::string* phoneuuid) {
  if (phoneuuid_ != &::google::protobuf::internal::kEmptyString) {
    delete phoneuuid_;
  }
  if (phoneuuid) {
    set_has_phoneuuid();
    phoneuuid_ = phoneuuid;
  } else {
    clear_has_phoneuuid();
    phoneuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 gameZone = 3;
inline bool ReqLogin::has_gamezone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqLogin::set_has_gamezone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqLogin::clear_has_gamezone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqLogin::clear_gamezone() {
  gamezone_ = 0u;
  clear_has_gamezone();
}
inline ::google::protobuf::uint32 ReqLogin::gamezone() const {
  return gamezone_;
}
inline void ReqLogin::set_gamezone(::google::protobuf::uint32 value) {
  set_has_gamezone();
  gamezone_ = value;
}

// required string account = 4;
inline bool ReqLogin::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqLogin::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqLogin::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqLogin::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ReqLogin::account() const {
  return *account_;
}
inline void ReqLogin::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ReqLogin::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ReqLogin::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLogin::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ReqLogin::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLogin::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .HelloKittyMsgData.NetType netType = 5;
inline bool ReqLogin::has_nettype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReqLogin::set_has_nettype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReqLogin::clear_has_nettype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReqLogin::clear_nettype() {
  nettype_ = 0;
  clear_has_nettype();
}
inline ::HelloKittyMsgData::NetType ReqLogin::nettype() const {
  return static_cast< ::HelloKittyMsgData::NetType >(nettype_);
}
inline void ReqLogin::set_nettype(::HelloKittyMsgData::NetType value) {
  assert(::HelloKittyMsgData::NetType_IsValid(value));
  set_has_nettype();
  nettype_ = value;
}

// required .HelloKittyMsgData.UserPlateType usertype = 6;
inline bool ReqLogin::has_usertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReqLogin::set_has_usertype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReqLogin::clear_has_usertype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReqLogin::clear_usertype() {
  usertype_ = 0;
  clear_has_usertype();
}
inline ::HelloKittyMsgData::UserPlateType ReqLogin::usertype() const {
  return static_cast< ::HelloKittyMsgData::UserPlateType >(usertype_);
}
inline void ReqLogin::set_usertype(::HelloKittyMsgData::UserPlateType value) {
  assert(::HelloKittyMsgData::UserPlateType_IsValid(value));
  set_has_usertype();
  usertype_ = value;
}

// -------------------------------------------------------------------

// AckLoginFailReturn

// required .HelloKittyMsgData.LoginFailReason failReason = 1;
inline bool AckLoginFailReturn::has_failreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLoginFailReturn::set_has_failreason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLoginFailReturn::clear_has_failreason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLoginFailReturn::clear_failreason() {
  failreason_ = 0;
  clear_has_failreason();
}
inline ::HelloKittyMsgData::LoginFailReason AckLoginFailReturn::failreason() const {
  return static_cast< ::HelloKittyMsgData::LoginFailReason >(failreason_);
}
inline void AckLoginFailReturn::set_failreason(::HelloKittyMsgData::LoginFailReason value) {
  assert(::HelloKittyMsgData::LoginFailReason_IsValid(value));
  set_has_failreason();
  failreason_ = value;
}

// -------------------------------------------------------------------

// AckLoginSuccessReturn

// required uint32 loginTempID = 1;
inline bool AckLoginSuccessReturn::has_logintempid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckLoginSuccessReturn::set_has_logintempid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckLoginSuccessReturn::clear_has_logintempid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckLoginSuccessReturn::clear_logintempid() {
  logintempid_ = 0u;
  clear_has_logintempid();
}
inline ::google::protobuf::uint32 AckLoginSuccessReturn::logintempid() const {
  return logintempid_;
}
inline void AckLoginSuccessReturn::set_logintempid(::google::protobuf::uint32 value) {
  set_has_logintempid();
  logintempid_ = value;
}

// required string gatewayIP = 2;
inline bool AckLoginSuccessReturn::has_gatewayip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckLoginSuccessReturn::set_has_gatewayip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckLoginSuccessReturn::clear_has_gatewayip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckLoginSuccessReturn::clear_gatewayip() {
  if (gatewayip_ != &::google::protobuf::internal::kEmptyString) {
    gatewayip_->clear();
  }
  clear_has_gatewayip();
}
inline const ::std::string& AckLoginSuccessReturn::gatewayip() const {
  return *gatewayip_;
}
inline void AckLoginSuccessReturn::set_gatewayip(const ::std::string& value) {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  gatewayip_->assign(value);
}
inline void AckLoginSuccessReturn::set_gatewayip(const char* value) {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  gatewayip_->assign(value);
}
inline void AckLoginSuccessReturn::set_gatewayip(const char* value, size_t size) {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  gatewayip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AckLoginSuccessReturn::mutable_gatewayip() {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  return gatewayip_;
}
inline ::std::string* AckLoginSuccessReturn::release_gatewayip() {
  clear_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gatewayip_;
    gatewayip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AckLoginSuccessReturn::set_allocated_gatewayip(::std::string* gatewayip) {
  if (gatewayip_ != &::google::protobuf::internal::kEmptyString) {
    delete gatewayip_;
  }
  if (gatewayip) {
    set_has_gatewayip();
    gatewayip_ = gatewayip;
  } else {
    clear_has_gatewayip();
    gatewayip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 gatewayPort = 3;
inline bool AckLoginSuccessReturn::has_gatewayport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AckLoginSuccessReturn::set_has_gatewayport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AckLoginSuccessReturn::clear_has_gatewayport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AckLoginSuccessReturn::clear_gatewayport() {
  gatewayport_ = 0u;
  clear_has_gatewayport();
}
inline ::google::protobuf::uint32 AckLoginSuccessReturn::gatewayport() const {
  return gatewayport_;
}
inline void AckLoginSuccessReturn::set_gatewayport(::google::protobuf::uint32 value) {
  set_has_gatewayport();
  gatewayport_ = value;
}

// repeated uint32 keyArr = 4;
inline int AckLoginSuccessReturn::keyarr_size() const {
  return keyarr_.size();
}
inline void AckLoginSuccessReturn::clear_keyarr() {
  keyarr_.Clear();
}
inline ::google::protobuf::uint32 AckLoginSuccessReturn::keyarr(int index) const {
  return keyarr_.Get(index);
}
inline void AckLoginSuccessReturn::set_keyarr(int index, ::google::protobuf::uint32 value) {
  keyarr_.Set(index, value);
}
inline void AckLoginSuccessReturn::add_keyarr(::google::protobuf::uint32 value) {
  keyarr_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
AckLoginSuccessReturn::keyarr() const {
  return keyarr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
AckLoginSuccessReturn::mutable_keyarr() {
  return &keyarr_;
}

// required .HelloKittyMsgData.LoginRetType loginRet = 5;
inline bool AckLoginSuccessReturn::has_loginret() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AckLoginSuccessReturn::set_has_loginret() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AckLoginSuccessReturn::clear_has_loginret() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AckLoginSuccessReturn::clear_loginret() {
  loginret_ = 0;
  clear_has_loginret();
}
inline ::HelloKittyMsgData::LoginRetType AckLoginSuccessReturn::loginret() const {
  return static_cast< ::HelloKittyMsgData::LoginRetType >(loginret_);
}
inline void AckLoginSuccessReturn::set_loginret(::HelloKittyMsgData::LoginRetType value) {
  assert(::HelloKittyMsgData::LoginRetType_IsValid(value));
  set_has_loginret();
  loginret_ = value;
}

// -------------------------------------------------------------------

// ReqLoginGateway

// required string account = 1;
inline bool ReqLoginGateway::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqLoginGateway::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqLoginGateway::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqLoginGateway::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ReqLoginGateway::account() const {
  return *account_;
}
inline void ReqLoginGateway::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ReqLoginGateway::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ReqLoginGateway::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLoginGateway::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ReqLoginGateway::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLoginGateway::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .HelloKittyMsgData.UserPlateType usertype = 2;
inline bool ReqLoginGateway::has_usertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqLoginGateway::set_has_usertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqLoginGateway::clear_has_usertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqLoginGateway::clear_usertype() {
  usertype_ = 0;
  clear_has_usertype();
}
inline ::HelloKittyMsgData::UserPlateType ReqLoginGateway::usertype() const {
  return static_cast< ::HelloKittyMsgData::UserPlateType >(usertype_);
}
inline void ReqLoginGateway::set_usertype(::HelloKittyMsgData::UserPlateType value) {
  assert(::HelloKittyMsgData::UserPlateType_IsValid(value));
  set_has_usertype();
  usertype_ = value;
}

// required .HelloKittyMsgData.PhoneType phoneType = 3;
inline bool ReqLoginGateway::has_phonetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqLoginGateway::set_has_phonetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqLoginGateway::clear_has_phonetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqLoginGateway::clear_phonetype() {
  phonetype_ = 0;
  clear_has_phonetype();
}
inline ::HelloKittyMsgData::PhoneType ReqLoginGateway::phonetype() const {
  return static_cast< ::HelloKittyMsgData::PhoneType >(phonetype_);
}
inline void ReqLoginGateway::set_phonetype(::HelloKittyMsgData::PhoneType value) {
  assert(::HelloKittyMsgData::PhoneType_IsValid(value));
  set_has_phonetype();
  phonetype_ = value;
}

// required string phoneUuid = 4;
inline bool ReqLoginGateway::has_phoneuuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReqLoginGateway::set_has_phoneuuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReqLoginGateway::clear_has_phoneuuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReqLoginGateway::clear_phoneuuid() {
  if (phoneuuid_ != &::google::protobuf::internal::kEmptyString) {
    phoneuuid_->clear();
  }
  clear_has_phoneuuid();
}
inline const ::std::string& ReqLoginGateway::phoneuuid() const {
  return *phoneuuid_;
}
inline void ReqLoginGateway::set_phoneuuid(const ::std::string& value) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(value);
}
inline void ReqLoginGateway::set_phoneuuid(const char* value) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(value);
}
inline void ReqLoginGateway::set_phoneuuid(const char* value, size_t size) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqLoginGateway::mutable_phoneuuid() {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  return phoneuuid_;
}
inline ::std::string* ReqLoginGateway::release_phoneuuid() {
  clear_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phoneuuid_;
    phoneuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqLoginGateway::set_allocated_phoneuuid(::std::string* phoneuuid) {
  if (phoneuuid_ != &::google::protobuf::internal::kEmptyString) {
    delete phoneuuid_;
  }
  if (phoneuuid) {
    set_has_phoneuuid();
    phoneuuid_ = phoneuuid;
  } else {
    clear_has_phoneuuid();
    phoneuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AckGameTime

// required uint64 gameTime = 1;
inline bool AckGameTime::has_gametime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckGameTime::set_has_gametime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckGameTime::clear_has_gametime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckGameTime::clear_gametime() {
  gametime_ = GOOGLE_ULONGLONG(0);
  clear_has_gametime();
}
inline ::google::protobuf::uint64 AckGameTime::gametime() const {
  return gametime_;
}
inline void AckGameTime::set_gametime(::google::protobuf::uint64 value) {
  set_has_gametime();
  gametime_ = value;
}

// -------------------------------------------------------------------

// UserBaseInfo

// required uint64 charId = 1;
inline bool UserBaseInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserBaseInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserBaseInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserBaseInfo::clear_charid() {
  charid_ = GOOGLE_ULONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::uint64 UserBaseInfo::charid() const {
  return charid_;
}
inline void UserBaseInfo::set_charid(::google::protobuf::uint64 value) {
  set_has_charid();
  charid_ = value;
}

// required string name = 2;
inline bool UserBaseInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserBaseInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserBaseInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserBaseInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserBaseInfo::name() const {
  return *name_;
}
inline void UserBaseInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserBaseInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserBaseInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBaseInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserBaseInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBaseInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .HelloKittyMsgData.SexType sex = 3;
inline bool UserBaseInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserBaseInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserBaseInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserBaseInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::HelloKittyMsgData::SexType UserBaseInfo::sex() const {
  return static_cast< ::HelloKittyMsgData::SexType >(sex_);
}
inline void UserBaseInfo::set_sex(::HelloKittyMsgData::SexType value) {
  assert(::HelloKittyMsgData::SexType_IsValid(value));
  set_has_sex();
  sex_ = value;
}

// required uint32 level = 4;
inline bool UserBaseInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserBaseInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserBaseInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserBaseInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 UserBaseInfo::level() const {
  return level_;
}
inline void UserBaseInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint64 exp = 5;
inline bool UserBaseInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserBaseInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserBaseInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserBaseInfo::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 UserBaseInfo::exp() const {
  return exp_;
}
inline void UserBaseInfo::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// required uint64 gold = 6;
inline bool UserBaseInfo::has_gold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserBaseInfo::set_has_gold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserBaseInfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserBaseInfo::clear_gold() {
  gold_ = GOOGLE_ULONGLONG(0);
  clear_has_gold();
}
inline ::google::protobuf::uint64 UserBaseInfo::gold() const {
  return gold_;
}
inline void UserBaseInfo::set_gold(::google::protobuf::uint64 value) {
  set_has_gold();
  gold_ = value;
}

// required uint64 gem = 7;
inline bool UserBaseInfo::has_gem() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserBaseInfo::set_has_gem() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserBaseInfo::clear_has_gem() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserBaseInfo::clear_gem() {
  gem_ = GOOGLE_ULONGLONG(0);
  clear_has_gem();
}
inline ::google::protobuf::uint64 UserBaseInfo::gem() const {
  return gem_;
}
inline void UserBaseInfo::set_gem(::google::protobuf::uint64 value) {
  set_has_gem();
  gem_ = value;
}

// required uint32 workernum = 8;
inline bool UserBaseInfo::has_workernum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserBaseInfo::set_has_workernum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserBaseInfo::clear_has_workernum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserBaseInfo::clear_workernum() {
  workernum_ = 0u;
  clear_has_workernum();
}
inline ::google::protobuf::uint32 UserBaseInfo::workernum() const {
  return workernum_;
}
inline void UserBaseInfo::set_workernum(::google::protobuf::uint32 value) {
  set_has_workernum();
  workernum_ = value;
}

// required uint32 friendval = 9;
inline bool UserBaseInfo::has_friendval() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserBaseInfo::set_has_friendval() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserBaseInfo::clear_has_friendval() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserBaseInfo::clear_friendval() {
  friendval_ = 0u;
  clear_has_friendval();
}
inline ::google::protobuf::uint32 UserBaseInfo::friendval() const {
  return friendval_;
}
inline void UserBaseInfo::set_friendval(::google::protobuf::uint32 value) {
  set_has_friendval();
  friendval_ = value;
}

// required uint32 happyval = 10;
inline bool UserBaseInfo::has_happyval() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserBaseInfo::set_has_happyval() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserBaseInfo::clear_has_happyval() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserBaseInfo::clear_happyval() {
  happyval_ = 0u;
  clear_has_happyval();
}
inline ::google::protobuf::uint32 UserBaseInfo::happyval() const {
  return happyval_;
}
inline void UserBaseInfo::set_happyval(::google::protobuf::uint32 value) {
  set_has_happyval();
  happyval_ = value;
}

// required uint32 randtoy = 11;
inline bool UserBaseInfo::has_randtoy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserBaseInfo::set_has_randtoy() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserBaseInfo::clear_has_randtoy() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserBaseInfo::clear_randtoy() {
  randtoy_ = 0u;
  clear_has_randtoy();
}
inline ::google::protobuf::uint32 UserBaseInfo::randtoy() const {
  return randtoy_;
}
inline void UserBaseInfo::set_randtoy(::google::protobuf::uint32 value) {
  set_has_randtoy();
  randtoy_ = value;
}

// required uint32 itemwarehousecap = 12;
inline bool UserBaseInfo::has_itemwarehousecap() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserBaseInfo::set_has_itemwarehousecap() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserBaseInfo::clear_has_itemwarehousecap() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserBaseInfo::clear_itemwarehousecap() {
  itemwarehousecap_ = 0u;
  clear_has_itemwarehousecap();
}
inline ::google::protobuf::uint32 UserBaseInfo::itemwarehousecap() const {
  return itemwarehousecap_;
}
inline void UserBaseInfo::set_itemwarehousecap(::google::protobuf::uint32 value) {
  set_has_itemwarehousecap();
  itemwarehousecap_ = value;
}

// required uint32 sweetval = 13;
inline bool UserBaseInfo::has_sweetval() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserBaseInfo::set_has_sweetval() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserBaseInfo::clear_has_sweetval() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserBaseInfo::clear_sweetval() {
  sweetval_ = 0u;
  clear_has_sweetval();
}
inline ::google::protobuf::uint32 UserBaseInfo::sweetval() const {
  return sweetval_;
}
inline void UserBaseInfo::set_sweetval(::google::protobuf::uint32 value) {
  set_has_sweetval();
  sweetval_ = value;
}

// required uint32 carnival = 14;
inline bool UserBaseInfo::has_carnival() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserBaseInfo::set_has_carnival() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserBaseInfo::clear_has_carnival() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserBaseInfo::clear_carnival() {
  carnival_ = 0u;
  clear_has_carnival();
}
inline ::google::protobuf::uint32 UserBaseInfo::carnival() const {
  return carnival_;
}
inline void UserBaseInfo::set_carnival(::google::protobuf::uint32 value) {
  set_has_carnival();
  carnival_ = value;
}

// required .HelloKittyMsgData.DressData dress = 15;
inline bool UserBaseInfo::has_dress() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserBaseInfo::set_has_dress() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserBaseInfo::clear_has_dress() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserBaseInfo::clear_dress() {
  if (dress_ != NULL) dress_->::HelloKittyMsgData::DressData::Clear();
  clear_has_dress();
}
inline const ::HelloKittyMsgData::DressData& UserBaseInfo::dress() const {
  return dress_ != NULL ? *dress_ : *default_instance_->dress_;
}
inline ::HelloKittyMsgData::DressData* UserBaseInfo::mutable_dress() {
  set_has_dress();
  if (dress_ == NULL) dress_ = new ::HelloKittyMsgData::DressData;
  return dress_;
}
inline ::HelloKittyMsgData::DressData* UserBaseInfo::release_dress() {
  clear_has_dress();
  ::HelloKittyMsgData::DressData* temp = dress_;
  dress_ = NULL;
  return temp;
}
inline void UserBaseInfo::set_allocated_dress(::HelloKittyMsgData::DressData* dress) {
  delete dress_;
  dress_ = dress;
  if (dress) {
    set_has_dress();
  } else {
    clear_has_dress();
  }
}

// repeated .HelloKittyMsgData.BuildBase buildinfo = 16;
inline int UserBaseInfo::buildinfo_size() const {
  return buildinfo_.size();
}
inline void UserBaseInfo::clear_buildinfo() {
  buildinfo_.Clear();
}
inline const ::HelloKittyMsgData::BuildBase& UserBaseInfo::buildinfo(int index) const {
  return buildinfo_.Get(index);
}
inline ::HelloKittyMsgData::BuildBase* UserBaseInfo::mutable_buildinfo(int index) {
  return buildinfo_.Mutable(index);
}
inline ::HelloKittyMsgData::BuildBase* UserBaseInfo::add_buildinfo() {
  return buildinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BuildBase >&
UserBaseInfo::buildinfo() const {
  return buildinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BuildBase >*
UserBaseInfo::mutable_buildinfo() {
  return &buildinfo_;
}

// required .HelloKittyMsgData.KittyGarden kittygarden = 17;
inline bool UserBaseInfo::has_kittygarden() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserBaseInfo::set_has_kittygarden() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserBaseInfo::clear_has_kittygarden() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserBaseInfo::clear_kittygarden() {
  if (kittygarden_ != NULL) kittygarden_->::HelloKittyMsgData::KittyGarden::Clear();
  clear_has_kittygarden();
}
inline const ::HelloKittyMsgData::KittyGarden& UserBaseInfo::kittygarden() const {
  return kittygarden_ != NULL ? *kittygarden_ : *default_instance_->kittygarden_;
}
inline ::HelloKittyMsgData::KittyGarden* UserBaseInfo::mutable_kittygarden() {
  set_has_kittygarden();
  if (kittygarden_ == NULL) kittygarden_ = new ::HelloKittyMsgData::KittyGarden;
  return kittygarden_;
}
inline ::HelloKittyMsgData::KittyGarden* UserBaseInfo::release_kittygarden() {
  clear_has_kittygarden();
  ::HelloKittyMsgData::KittyGarden* temp = kittygarden_;
  kittygarden_ = NULL;
  return temp;
}
inline void UserBaseInfo::set_allocated_kittygarden(::HelloKittyMsgData::KittyGarden* kittygarden) {
  delete kittygarden_;
  kittygarden_ = kittygarden;
  if (kittygarden) {
    set_has_kittygarden();
  } else {
    clear_has_kittygarden();
  }
}

// repeated .HelloKittyMsgData.BuildProduce produce = 18;
inline int UserBaseInfo::produce_size() const {
  return produce_.size();
}
inline void UserBaseInfo::clear_produce() {
  produce_.Clear();
}
inline const ::HelloKittyMsgData::BuildProduce& UserBaseInfo::produce(int index) const {
  return produce_.Get(index);
}
inline ::HelloKittyMsgData::BuildProduce* UserBaseInfo::mutable_produce(int index) {
  return produce_.Mutable(index);
}
inline ::HelloKittyMsgData::BuildProduce* UserBaseInfo::add_produce() {
  return produce_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BuildProduce >&
UserBaseInfo::produce() const {
  return produce_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BuildProduce >*
UserBaseInfo::mutable_produce() {
  return &produce_;
}

// repeated .HelloKittyMsgData.StoreFunctionCell produceitem = 19;
inline int UserBaseInfo::produceitem_size() const {
  return produceitem_.size();
}
inline void UserBaseInfo::clear_produceitem() {
  produceitem_.Clear();
}
inline const ::HelloKittyMsgData::StoreFunctionCell& UserBaseInfo::produceitem(int index) const {
  return produceitem_.Get(index);
}
inline ::HelloKittyMsgData::StoreFunctionCell* UserBaseInfo::mutable_produceitem(int index) {
  return produceitem_.Mutable(index);
}
inline ::HelloKittyMsgData::StoreFunctionCell* UserBaseInfo::add_produceitem() {
  return produceitem_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::StoreFunctionCell >&
UserBaseInfo::produceitem() const {
  return produceitem_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::StoreFunctionCell >*
UserBaseInfo::mutable_produceitem() {
  return &produceitem_;
}

// repeated .HelloKittyMsgData.BufferInfo bufferinfo = 20;
inline int UserBaseInfo::bufferinfo_size() const {
  return bufferinfo_.size();
}
inline void UserBaseInfo::clear_bufferinfo() {
  bufferinfo_.Clear();
}
inline const ::HelloKittyMsgData::BufferInfo& UserBaseInfo::bufferinfo(int index) const {
  return bufferinfo_.Get(index);
}
inline ::HelloKittyMsgData::BufferInfo* UserBaseInfo::mutable_bufferinfo(int index) {
  return bufferinfo_.Mutable(index);
}
inline ::HelloKittyMsgData::BufferInfo* UserBaseInfo::add_bufferinfo() {
  return bufferinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BufferInfo >&
UserBaseInfo::bufferinfo() const {
  return bufferinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BufferInfo >*
UserBaseInfo::mutable_bufferinfo() {
  return &bufferinfo_;
}

// repeated .HelloKittyMsgData.UseCardInfo usecard = 21;
inline int UserBaseInfo::usecard_size() const {
  return usecard_.size();
}
inline void UserBaseInfo::clear_usecard() {
  usecard_.Clear();
}
inline const ::HelloKittyMsgData::UseCardInfo& UserBaseInfo::usecard(int index) const {
  return usecard_.Get(index);
}
inline ::HelloKittyMsgData::UseCardInfo* UserBaseInfo::mutable_usecard(int index) {
  return usecard_.Mutable(index);
}
inline ::HelloKittyMsgData::UseCardInfo* UserBaseInfo::add_usecard() {
  return usecard_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::UseCardInfo >&
UserBaseInfo::usecard() const {
  return usecard_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::UseCardInfo >*
UserBaseInfo::mutable_usecard() {
  return &usecard_;
}

// repeated .HelloKittyMsgData.BufferData externbuffer = 22;
inline int UserBaseInfo::externbuffer_size() const {
  return externbuffer_.size();
}
inline void UserBaseInfo::clear_externbuffer() {
  externbuffer_.Clear();
}
inline const ::HelloKittyMsgData::BufferData& UserBaseInfo::externbuffer(int index) const {
  return externbuffer_.Get(index);
}
inline ::HelloKittyMsgData::BufferData* UserBaseInfo::mutable_externbuffer(int index) {
  return externbuffer_.Mutable(index);
}
inline ::HelloKittyMsgData::BufferData* UserBaseInfo::add_externbuffer() {
  return externbuffer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BufferData >&
UserBaseInfo::externbuffer() const {
  return externbuffer_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BufferData >*
UserBaseInfo::mutable_externbuffer() {
  return &externbuffer_;
}

// repeated .HelloKittyMsgData.RubbishData rubbish = 23;
inline int UserBaseInfo::rubbish_size() const {
  return rubbish_.size();
}
inline void UserBaseInfo::clear_rubbish() {
  rubbish_.Clear();
}
inline const ::HelloKittyMsgData::RubbishData& UserBaseInfo::rubbish(int index) const {
  return rubbish_.Get(index);
}
inline ::HelloKittyMsgData::RubbishData* UserBaseInfo::mutable_rubbish(int index) {
  return rubbish_.Mutable(index);
}
inline ::HelloKittyMsgData::RubbishData* UserBaseInfo::add_rubbish() {
  return rubbish_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::RubbishData >&
UserBaseInfo::rubbish() const {
  return rubbish_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::RubbishData >*
UserBaseInfo::mutable_rubbish() {
  return &rubbish_;
}

// required .HelloKittyMsgData.Evententer eventinit = 24;
inline bool UserBaseInfo::has_eventinit() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void UserBaseInfo::set_has_eventinit() {
  _has_bits_[0] |= 0x00800000u;
}
inline void UserBaseInfo::clear_has_eventinit() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void UserBaseInfo::clear_eventinit() {
  if (eventinit_ != NULL) eventinit_->::HelloKittyMsgData::Evententer::Clear();
  clear_has_eventinit();
}
inline const ::HelloKittyMsgData::Evententer& UserBaseInfo::eventinit() const {
  return eventinit_ != NULL ? *eventinit_ : *default_instance_->eventinit_;
}
inline ::HelloKittyMsgData::Evententer* UserBaseInfo::mutable_eventinit() {
  set_has_eventinit();
  if (eventinit_ == NULL) eventinit_ = new ::HelloKittyMsgData::Evententer;
  return eventinit_;
}
inline ::HelloKittyMsgData::Evententer* UserBaseInfo::release_eventinit() {
  clear_has_eventinit();
  ::HelloKittyMsgData::Evententer* temp = eventinit_;
  eventinit_ = NULL;
  return temp;
}
inline void UserBaseInfo::set_allocated_eventinit(::HelloKittyMsgData::Evententer* eventinit) {
  delete eventinit_;
  eventinit_ = eventinit;
  if (eventinit) {
    set_has_eventinit();
  } else {
    clear_has_eventinit();
  }
}

// repeated .HelloKittyMsgData.BurstEvent burstevent = 25;
inline int UserBaseInfo::burstevent_size() const {
  return burstevent_.size();
}
inline void UserBaseInfo::clear_burstevent() {
  burstevent_.Clear();
}
inline const ::HelloKittyMsgData::BurstEvent& UserBaseInfo::burstevent(int index) const {
  return burstevent_.Get(index);
}
inline ::HelloKittyMsgData::BurstEvent* UserBaseInfo::mutable_burstevent(int index) {
  return burstevent_.Mutable(index);
}
inline ::HelloKittyMsgData::BurstEvent* UserBaseInfo::add_burstevent() {
  return burstevent_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BurstEvent >&
UserBaseInfo::burstevent() const {
  return burstevent_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::BurstEvent >*
UserBaseInfo::mutable_burstevent() {
  return &burstevent_;
}

// optional uint64 familyid = 26 [default = 0];
inline bool UserBaseInfo::has_familyid() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void UserBaseInfo::set_has_familyid() {
  _has_bits_[0] |= 0x02000000u;
}
inline void UserBaseInfo::clear_has_familyid() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void UserBaseInfo::clear_familyid() {
  familyid_ = GOOGLE_ULONGLONG(0);
  clear_has_familyid();
}
inline ::google::protobuf::uint64 UserBaseInfo::familyid() const {
  return familyid_;
}
inline void UserBaseInfo::set_familyid(::google::protobuf::uint64 value) {
  set_has_familyid();
  familyid_ = value;
}

// -------------------------------------------------------------------

// AckUserInfo

// required bool hasUser = 1;
inline bool AckUserInfo::has_hasuser() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUserInfo::set_has_hasuser() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUserInfo::clear_has_hasuser() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUserInfo::clear_hasuser() {
  hasuser_ = false;
  clear_has_hasuser();
}
inline bool AckUserInfo::hasuser() const {
  return hasuser_;
}
inline void AckUserInfo::set_hasuser(bool value) {
  set_has_hasuser();
  hasuser_ = value;
}

// required .HelloKittyMsgData.UserBaseInfo userBase = 2;
inline bool AckUserInfo::has_userbase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AckUserInfo::set_has_userbase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AckUserInfo::clear_has_userbase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AckUserInfo::clear_userbase() {
  if (userbase_ != NULL) userbase_->::HelloKittyMsgData::UserBaseInfo::Clear();
  clear_has_userbase();
}
inline const ::HelloKittyMsgData::UserBaseInfo& AckUserInfo::userbase() const {
  return userbase_ != NULL ? *userbase_ : *default_instance_->userbase_;
}
inline ::HelloKittyMsgData::UserBaseInfo* AckUserInfo::mutable_userbase() {
  set_has_userbase();
  if (userbase_ == NULL) userbase_ = new ::HelloKittyMsgData::UserBaseInfo;
  return userbase_;
}
inline ::HelloKittyMsgData::UserBaseInfo* AckUserInfo::release_userbase() {
  clear_has_userbase();
  ::HelloKittyMsgData::UserBaseInfo* temp = userbase_;
  userbase_ = NULL;
  return temp;
}
inline void AckUserInfo::set_allocated_userbase(::HelloKittyMsgData::UserBaseInfo* userbase) {
  delete userbase_;
  userbase_ = userbase;
  if (userbase) {
    set_has_userbase();
  } else {
    clear_has_userbase();
  }
}

// -------------------------------------------------------------------

// ReqCreateRole

// required string name = 1;
inline bool ReqCreateRole::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqCreateRole::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqCreateRole::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqCreateRole::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ReqCreateRole::name() const {
  return *name_;
}
inline void ReqCreateRole::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ReqCreateRole::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ReqCreateRole::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReqCreateRole::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ReqCreateRole::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReqCreateRole::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .HelloKittyMsgData.SexType sex = 2;
inline bool ReqCreateRole::has_sex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqCreateRole::set_has_sex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqCreateRole::clear_has_sex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqCreateRole::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::HelloKittyMsgData::SexType ReqCreateRole::sex() const {
  return static_cast< ::HelloKittyMsgData::SexType >(sex_);
}
inline void ReqCreateRole::set_sex(::HelloKittyMsgData::SexType value) {
  assert(::HelloKittyMsgData::SexType_IsValid(value));
  set_has_sex();
  sex_ = value;
}

// required uint32 heroId = 3;
inline bool ReqCreateRole::has_heroid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReqCreateRole::set_has_heroid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReqCreateRole::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReqCreateRole::clear_heroid() {
  heroid_ = 0u;
  clear_has_heroid();
}
inline ::google::protobuf::uint32 ReqCreateRole::heroid() const {
  return heroid_;
}
inline void ReqCreateRole::set_heroid(::google::protobuf::uint32 value) {
  set_has_heroid();
  heroid_ = value;
}

// -------------------------------------------------------------------

// ReqOpReceiveWorldChatCmd

// required .HelloKittyMsgData.SwitchType switchFlg = 1;
inline bool ReqOpReceiveWorldChatCmd::has_switchflg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqOpReceiveWorldChatCmd::set_has_switchflg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqOpReceiveWorldChatCmd::clear_has_switchflg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqOpReceiveWorldChatCmd::clear_switchflg() {
  switchflg_ = 0;
  clear_has_switchflg();
}
inline ::HelloKittyMsgData::SwitchType ReqOpReceiveWorldChatCmd::switchflg() const {
  return static_cast< ::HelloKittyMsgData::SwitchType >(switchflg_);
}
inline void ReqOpReceiveWorldChatCmd::set_switchflg(::HelloKittyMsgData::SwitchType value) {
  assert(::HelloKittyMsgData::SwitchType_IsValid(value));
  set_has_switchflg();
  switchflg_ = value;
}

// -------------------------------------------------------------------

// AckNoticeClient

// required .HelloKittyMsgData.NoticeType noticeType = 1;
inline bool AckNoticeClient::has_noticetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckNoticeClient::set_has_noticetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckNoticeClient::clear_has_noticetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckNoticeClient::clear_noticetype() {
  noticetype_ = 0;
  clear_has_noticetype();
}
inline ::HelloKittyMsgData::NoticeType AckNoticeClient::noticetype() const {
  return static_cast< ::HelloKittyMsgData::NoticeType >(noticetype_);
}
inline void AckNoticeClient::set_noticetype(::HelloKittyMsgData::NoticeType value) {
  assert(::HelloKittyMsgData::NoticeType_IsValid(value));
  set_has_noticetype();
  noticetype_ = value;
}

// -------------------------------------------------------------------

// AckFlushUserInfo

// required .HelloKittyMsgData.UserBaseInfo userBase = 1;
inline bool AckFlushUserInfo::has_userbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckFlushUserInfo::set_has_userbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckFlushUserInfo::clear_has_userbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckFlushUserInfo::clear_userbase() {
  if (userbase_ != NULL) userbase_->::HelloKittyMsgData::UserBaseInfo::Clear();
  clear_has_userbase();
}
inline const ::HelloKittyMsgData::UserBaseInfo& AckFlushUserInfo::userbase() const {
  return userbase_ != NULL ? *userbase_ : *default_instance_->userbase_;
}
inline ::HelloKittyMsgData::UserBaseInfo* AckFlushUserInfo::mutable_userbase() {
  set_has_userbase();
  if (userbase_ == NULL) userbase_ = new ::HelloKittyMsgData::UserBaseInfo;
  return userbase_;
}
inline ::HelloKittyMsgData::UserBaseInfo* AckFlushUserInfo::release_userbase() {
  clear_has_userbase();
  ::HelloKittyMsgData::UserBaseInfo* temp = userbase_;
  userbase_ = NULL;
  return temp;
}
inline void AckFlushUserInfo::set_allocated_userbase(::HelloKittyMsgData::UserBaseInfo* userbase) {
  delete userbase_;
  userbase_ = userbase;
  if (userbase) {
    set_has_userbase();
  } else {
    clear_has_userbase();
  }
}

// -------------------------------------------------------------------

// ReqLogout


// @@protoc_insertion_point(namespace_scope)

}  // namespace HelloKittyMsgData

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::PhoneType>() {
  return ::HelloKittyMsgData::PhoneType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::NetType>() {
  return ::HelloKittyMsgData::NetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::UserPlateType>() {
  return ::HelloKittyMsgData::UserPlateType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::LoginFailReason>() {
  return ::HelloKittyMsgData::LoginFailReason_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::LoginRetType>() {
  return ::HelloKittyMsgData::LoginRetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::SexType>() {
  return ::HelloKittyMsgData::SexType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::SwitchType>() {
  return ::HelloKittyMsgData::SwitchType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::NoticeType>() {
  return ::HelloKittyMsgData::NoticeType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_login_2eproto__INCLUDED
