// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: warehouse.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "warehouse.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace HelloKittyMsgData {

namespace {

const ::google::protobuf::Descriptor* ReqStoreItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReqStoreItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckFlushWareHouse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckFlushWareHouse_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReqAddItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReqAddItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckUpdateItem_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckUpdateItem_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckAddItemReturn_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckAddItemReturn_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckFlushWareBuild_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckFlushWareBuild_reflection_ = NULL;
const ::google::protobuf::Descriptor* AckUpdateWareBuid_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AckUpdateWareBuid_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReqPayGrid_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReqPayGrid_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* StoreItemType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_warehouse_2eproto() {
  protobuf_AddDesc_warehouse_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "warehouse.proto");
  GOOGLE_CHECK(file != NULL);
  ReqStoreItem_descriptor_ = file->message_type(0);
  static const int ReqStoreItem_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqStoreItem, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqStoreItem, charid_),
  };
  ReqStoreItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReqStoreItem_descriptor_,
      ReqStoreItem::default_instance_,
      ReqStoreItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqStoreItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqStoreItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReqStoreItem));
  AckFlushWareHouse_descriptor_ = file->message_type(1);
  static const int AckFlushWareHouse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckFlushWareHouse, store_items_),
  };
  AckFlushWareHouse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckFlushWareHouse_descriptor_,
      AckFlushWareHouse::default_instance_,
      AckFlushWareHouse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckFlushWareHouse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckFlushWareHouse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckFlushWareHouse));
  ReqAddItem_descriptor_ = file->message_type(2);
  static const int ReqAddItem_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqAddItem, item_),
  };
  ReqAddItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReqAddItem_descriptor_,
      ReqAddItem::default_instance_,
      ReqAddItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqAddItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqAddItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReqAddItem));
  AckUpdateItem_descriptor_ = file->message_type(3);
  static const int AckUpdateItem_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpdateItem, item_),
  };
  AckUpdateItem_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckUpdateItem_descriptor_,
      AckUpdateItem::default_instance_,
      AckUpdateItem_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpdateItem, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpdateItem, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckUpdateItem));
  AckAddItemReturn_descriptor_ = file->message_type(4);
  static const int AckAddItemReturn_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAddItemReturn, ret_),
  };
  AckAddItemReturn_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckAddItemReturn_descriptor_,
      AckAddItemReturn::default_instance_,
      AckAddItemReturn_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAddItemReturn, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckAddItemReturn, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckAddItemReturn));
  AckFlushWareBuild_descriptor_ = file->message_type(5);
  static const int AckFlushWareBuild_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckFlushWareBuild, warebuild_),
  };
  AckFlushWareBuild_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckFlushWareBuild_descriptor_,
      AckFlushWareBuild::default_instance_,
      AckFlushWareBuild_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckFlushWareBuild, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckFlushWareBuild, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckFlushWareBuild));
  AckUpdateWareBuid_descriptor_ = file->message_type(6);
  static const int AckUpdateWareBuid_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpdateWareBuid, warebuild_),
  };
  AckUpdateWareBuid_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AckUpdateWareBuid_descriptor_,
      AckUpdateWareBuid::default_instance_,
      AckUpdateWareBuid_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpdateWareBuid, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AckUpdateWareBuid, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AckUpdateWareBuid));
  ReqPayGrid_descriptor_ = file->message_type(7);
  static const int ReqPayGrid_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqPayGrid, grid_),
  };
  ReqPayGrid_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ReqPayGrid_descriptor_,
      ReqPayGrid::default_instance_,
      ReqPayGrid_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqPayGrid, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReqPayGrid, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ReqPayGrid));
  StoreItemType_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_warehouse_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReqStoreItem_descriptor_, &ReqStoreItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckFlushWareHouse_descriptor_, &AckFlushWareHouse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReqAddItem_descriptor_, &ReqAddItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckUpdateItem_descriptor_, &AckUpdateItem::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckAddItemReturn_descriptor_, &AckAddItemReturn::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckFlushWareBuild_descriptor_, &AckFlushWareBuild::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AckUpdateWareBuid_descriptor_, &AckUpdateWareBuid::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ReqPayGrid_descriptor_, &ReqPayGrid::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_warehouse_2eproto() {
  delete ReqStoreItem::default_instance_;
  delete ReqStoreItem_reflection_;
  delete AckFlushWareHouse::default_instance_;
  delete AckFlushWareHouse_reflection_;
  delete ReqAddItem::default_instance_;
  delete ReqAddItem_reflection_;
  delete AckUpdateItem::default_instance_;
  delete AckUpdateItem_reflection_;
  delete AckAddItemReturn::default_instance_;
  delete AckAddItemReturn_reflection_;
  delete AckFlushWareBuild::default_instance_;
  delete AckFlushWareBuild_reflection_;
  delete AckUpdateWareBuid::default_instance_;
  delete AckUpdateWareBuid_reflection_;
  delete ReqPayGrid::default_instance_;
  delete ReqPayGrid_reflection_;
}

void protobuf_AddDesc_warehouse_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::HelloKittyMsgData::protobuf_AddDesc_trade_2eproto();
  ::HelloKittyMsgData::protobuf_AddDesc_build_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\017warehouse.proto\022\021HelloKittyMsgData\032\013tr"
    "ade.proto\032\013build.proto\"N\n\014ReqStoreItem\022."
    "\n\004type\030\001 \002(\0162 .HelloKittyMsgData.StoreIt"
    "emType\022\016\n\006charid\030\002 \002(\004\"H\n\021AckFlushWareHo"
    "use\0223\n\013store_items\030\001 \003(\0132\036.HelloKittyMsg"
    "Data.PbStoreItem\":\n\nReqAddItem\022,\n\004item\030\001"
    " \002(\0132\036.HelloKittyMsgData.PbStoreItem\"=\n\r"
    "AckUpdateItem\022,\n\004item\030\001 \002(\0132\036.HelloKitty"
    "MsgData.PbStoreItem\"\037\n\020AckAddItemReturn\022"
    "\013\n\003ret\030\001 \002(\010\"M\n\021AckFlushWareBuild\0228\n\twar"
    "ebuild\030\001 \003(\0132%.HelloKittyMsgData.WareHou"
    "seBuildBase\"M\n\021AckUpdateWareBuid\0228\n\tware"
    "build\030\001 \002(\0132%.HelloKittyMsgData.WareHous"
    "eBuildBase\"\032\n\nReqPayGrid\022\014\n\004grid\030\001 \002(\r*U"
    "\n\rStoreItemType\022\031\n\025Store_Type_Ware_House"
    "\020\000\022\024\n\020Store_Type_Build\020\001\022\023\n\017Store_Type_S"
    "ale\020\002", 645);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "warehouse.proto", &protobuf_RegisterTypes);
  ReqStoreItem::default_instance_ = new ReqStoreItem();
  AckFlushWareHouse::default_instance_ = new AckFlushWareHouse();
  ReqAddItem::default_instance_ = new ReqAddItem();
  AckUpdateItem::default_instance_ = new AckUpdateItem();
  AckAddItemReturn::default_instance_ = new AckAddItemReturn();
  AckFlushWareBuild::default_instance_ = new AckFlushWareBuild();
  AckUpdateWareBuid::default_instance_ = new AckUpdateWareBuid();
  ReqPayGrid::default_instance_ = new ReqPayGrid();
  ReqStoreItem::default_instance_->InitAsDefaultInstance();
  AckFlushWareHouse::default_instance_->InitAsDefaultInstance();
  ReqAddItem::default_instance_->InitAsDefaultInstance();
  AckUpdateItem::default_instance_->InitAsDefaultInstance();
  AckAddItemReturn::default_instance_->InitAsDefaultInstance();
  AckFlushWareBuild::default_instance_->InitAsDefaultInstance();
  AckUpdateWareBuid::default_instance_->InitAsDefaultInstance();
  ReqPayGrid::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_warehouse_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_warehouse_2eproto {
  StaticDescriptorInitializer_warehouse_2eproto() {
    protobuf_AddDesc_warehouse_2eproto();
  }
} static_descriptor_initializer_warehouse_2eproto_;
const ::google::protobuf::EnumDescriptor* StoreItemType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StoreItemType_descriptor_;
}
bool StoreItemType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int ReqStoreItem::kTypeFieldNumber;
const int ReqStoreItem::kCharidFieldNumber;
#endif  // !_MSC_VER

ReqStoreItem::ReqStoreItem()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReqStoreItem::InitAsDefaultInstance() {
}

ReqStoreItem::ReqStoreItem(const ReqStoreItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReqStoreItem::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  charid_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqStoreItem::~ReqStoreItem() {
  SharedDtor();
}

void ReqStoreItem::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReqStoreItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReqStoreItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReqStoreItem_descriptor_;
}

const ReqStoreItem& ReqStoreItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_warehouse_2eproto();
  return *default_instance_;
}

ReqStoreItem* ReqStoreItem::default_instance_ = NULL;

ReqStoreItem* ReqStoreItem::New() const {
  return new ReqStoreItem;
}

void ReqStoreItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    charid_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReqStoreItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .HelloKittyMsgData.StoreItemType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::HelloKittyMsgData::StoreItemType_IsValid(value)) {
            set_type(static_cast< ::HelloKittyMsgData::StoreItemType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_charid;
        break;
      }

      // required uint64 charid = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_charid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &charid_)));
          set_has_charid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqStoreItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .HelloKittyMsgData.StoreItemType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required uint64 charid = 2;
  if (has_charid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->charid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReqStoreItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .HelloKittyMsgData.StoreItemType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required uint64 charid = 2;
  if (has_charid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->charid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReqStoreItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .HelloKittyMsgData.StoreItemType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required uint64 charid = 2;
    if (has_charid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->charid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqStoreItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReqStoreItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReqStoreItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReqStoreItem::MergeFrom(const ReqStoreItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_charid()) {
      set_charid(from.charid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReqStoreItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReqStoreItem::CopyFrom(const ReqStoreItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqStoreItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ReqStoreItem::Swap(ReqStoreItem* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(charid_, other->charid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReqStoreItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReqStoreItem_descriptor_;
  metadata.reflection = ReqStoreItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckFlushWareHouse::kStoreItemsFieldNumber;
#endif  // !_MSC_VER

AckFlushWareHouse::AckFlushWareHouse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckFlushWareHouse::InitAsDefaultInstance() {
}

AckFlushWareHouse::AckFlushWareHouse(const AckFlushWareHouse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckFlushWareHouse::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckFlushWareHouse::~AckFlushWareHouse() {
  SharedDtor();
}

void AckFlushWareHouse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckFlushWareHouse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckFlushWareHouse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckFlushWareHouse_descriptor_;
}

const AckFlushWareHouse& AckFlushWareHouse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_warehouse_2eproto();
  return *default_instance_;
}

AckFlushWareHouse* AckFlushWareHouse::default_instance_ = NULL;

AckFlushWareHouse* AckFlushWareHouse::New() const {
  return new AckFlushWareHouse;
}

void AckFlushWareHouse::Clear() {
  store_items_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckFlushWareHouse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .HelloKittyMsgData.PbStoreItem store_items = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_store_items:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_store_items()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_store_items;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckFlushWareHouse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .HelloKittyMsgData.PbStoreItem store_items = 1;
  for (int i = 0; i < this->store_items_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->store_items(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckFlushWareHouse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .HelloKittyMsgData.PbStoreItem store_items = 1;
  for (int i = 0; i < this->store_items_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->store_items(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckFlushWareHouse::ByteSize() const {
  int total_size = 0;

  // repeated .HelloKittyMsgData.PbStoreItem store_items = 1;
  total_size += 1 * this->store_items_size();
  for (int i = 0; i < this->store_items_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->store_items(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckFlushWareHouse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckFlushWareHouse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckFlushWareHouse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckFlushWareHouse::MergeFrom(const AckFlushWareHouse& from) {
  GOOGLE_CHECK_NE(&from, this);
  store_items_.MergeFrom(from.store_items_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckFlushWareHouse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckFlushWareHouse::CopyFrom(const AckFlushWareHouse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckFlushWareHouse::IsInitialized() const {

  for (int i = 0; i < store_items_size(); i++) {
    if (!this->store_items(i).IsInitialized()) return false;
  }
  return true;
}

void AckFlushWareHouse::Swap(AckFlushWareHouse* other) {
  if (other != this) {
    store_items_.Swap(&other->store_items_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckFlushWareHouse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckFlushWareHouse_descriptor_;
  metadata.reflection = AckFlushWareHouse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReqAddItem::kItemFieldNumber;
#endif  // !_MSC_VER

ReqAddItem::ReqAddItem()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReqAddItem::InitAsDefaultInstance() {
  item_ = const_cast< ::HelloKittyMsgData::PbStoreItem*>(&::HelloKittyMsgData::PbStoreItem::default_instance());
}

ReqAddItem::ReqAddItem(const ReqAddItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReqAddItem::SharedCtor() {
  _cached_size_ = 0;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqAddItem::~ReqAddItem() {
  SharedDtor();
}

void ReqAddItem::SharedDtor() {
  if (this != default_instance_) {
    delete item_;
  }
}

void ReqAddItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReqAddItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReqAddItem_descriptor_;
}

const ReqAddItem& ReqAddItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_warehouse_2eproto();
  return *default_instance_;
}

ReqAddItem* ReqAddItem::default_instance_ = NULL;

ReqAddItem* ReqAddItem::New() const {
  return new ReqAddItem;
}

void ReqAddItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_item()) {
      if (item_ != NULL) item_->::HelloKittyMsgData::PbStoreItem::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReqAddItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .HelloKittyMsgData.PbStoreItem item = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqAddItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .HelloKittyMsgData.PbStoreItem item = 1;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->item(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReqAddItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .HelloKittyMsgData.PbStoreItem item = 1;
  if (has_item()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->item(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReqAddItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .HelloKittyMsgData.PbStoreItem item = 1;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqAddItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReqAddItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReqAddItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReqAddItem::MergeFrom(const ReqAddItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item()) {
      mutable_item()->::HelloKittyMsgData::PbStoreItem::MergeFrom(from.item());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReqAddItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReqAddItem::CopyFrom(const ReqAddItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqAddItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_item()) {
    if (!this->item().IsInitialized()) return false;
  }
  return true;
}

void ReqAddItem::Swap(ReqAddItem* other) {
  if (other != this) {
    std::swap(item_, other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReqAddItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReqAddItem_descriptor_;
  metadata.reflection = ReqAddItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckUpdateItem::kItemFieldNumber;
#endif  // !_MSC_VER

AckUpdateItem::AckUpdateItem()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckUpdateItem::InitAsDefaultInstance() {
  item_ = const_cast< ::HelloKittyMsgData::PbStoreItem*>(&::HelloKittyMsgData::PbStoreItem::default_instance());
}

AckUpdateItem::AckUpdateItem(const AckUpdateItem& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckUpdateItem::SharedCtor() {
  _cached_size_ = 0;
  item_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckUpdateItem::~AckUpdateItem() {
  SharedDtor();
}

void AckUpdateItem::SharedDtor() {
  if (this != default_instance_) {
    delete item_;
  }
}

void AckUpdateItem::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckUpdateItem::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckUpdateItem_descriptor_;
}

const AckUpdateItem& AckUpdateItem::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_warehouse_2eproto();
  return *default_instance_;
}

AckUpdateItem* AckUpdateItem::default_instance_ = NULL;

AckUpdateItem* AckUpdateItem::New() const {
  return new AckUpdateItem;
}

void AckUpdateItem::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_item()) {
      if (item_ != NULL) item_->::HelloKittyMsgData::PbStoreItem::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckUpdateItem::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .HelloKittyMsgData.PbStoreItem item = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_item()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckUpdateItem::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .HelloKittyMsgData.PbStoreItem item = 1;
  if (has_item()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->item(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckUpdateItem::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .HelloKittyMsgData.PbStoreItem item = 1;
  if (has_item()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->item(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckUpdateItem::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .HelloKittyMsgData.PbStoreItem item = 1;
    if (has_item()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->item());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckUpdateItem::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckUpdateItem* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckUpdateItem*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckUpdateItem::MergeFrom(const AckUpdateItem& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_item()) {
      mutable_item()->::HelloKittyMsgData::PbStoreItem::MergeFrom(from.item());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckUpdateItem::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckUpdateItem::CopyFrom(const AckUpdateItem& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckUpdateItem::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_item()) {
    if (!this->item().IsInitialized()) return false;
  }
  return true;
}

void AckUpdateItem::Swap(AckUpdateItem* other) {
  if (other != this) {
    std::swap(item_, other->item_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckUpdateItem::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckUpdateItem_descriptor_;
  metadata.reflection = AckUpdateItem_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckAddItemReturn::kRetFieldNumber;
#endif  // !_MSC_VER

AckAddItemReturn::AckAddItemReturn()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckAddItemReturn::InitAsDefaultInstance() {
}

AckAddItemReturn::AckAddItemReturn(const AckAddItemReturn& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckAddItemReturn::SharedCtor() {
  _cached_size_ = 0;
  ret_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckAddItemReturn::~AckAddItemReturn() {
  SharedDtor();
}

void AckAddItemReturn::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckAddItemReturn::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckAddItemReturn::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckAddItemReturn_descriptor_;
}

const AckAddItemReturn& AckAddItemReturn::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_warehouse_2eproto();
  return *default_instance_;
}

AckAddItemReturn* AckAddItemReturn::default_instance_ = NULL;

AckAddItemReturn* AckAddItemReturn::New() const {
  return new AckAddItemReturn;
}

void AckAddItemReturn::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ret_ = false;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckAddItemReturn::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bool ret = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &ret_)));
          set_has_ret();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckAddItemReturn::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required bool ret = 1;
  if (has_ret()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->ret(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckAddItemReturn::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required bool ret = 1;
  if (has_ret()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->ret(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckAddItemReturn::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required bool ret = 1;
    if (has_ret()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckAddItemReturn::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckAddItemReturn* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckAddItemReturn*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckAddItemReturn::MergeFrom(const AckAddItemReturn& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ret()) {
      set_ret(from.ret());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckAddItemReturn::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckAddItemReturn::CopyFrom(const AckAddItemReturn& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckAddItemReturn::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void AckAddItemReturn::Swap(AckAddItemReturn* other) {
  if (other != this) {
    std::swap(ret_, other->ret_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckAddItemReturn::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckAddItemReturn_descriptor_;
  metadata.reflection = AckAddItemReturn_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckFlushWareBuild::kWarebuildFieldNumber;
#endif  // !_MSC_VER

AckFlushWareBuild::AckFlushWareBuild()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckFlushWareBuild::InitAsDefaultInstance() {
}

AckFlushWareBuild::AckFlushWareBuild(const AckFlushWareBuild& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckFlushWareBuild::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckFlushWareBuild::~AckFlushWareBuild() {
  SharedDtor();
}

void AckFlushWareBuild::SharedDtor() {
  if (this != default_instance_) {
  }
}

void AckFlushWareBuild::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckFlushWareBuild::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckFlushWareBuild_descriptor_;
}

const AckFlushWareBuild& AckFlushWareBuild::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_warehouse_2eproto();
  return *default_instance_;
}

AckFlushWareBuild* AckFlushWareBuild::default_instance_ = NULL;

AckFlushWareBuild* AckFlushWareBuild::New() const {
  return new AckFlushWareBuild;
}

void AckFlushWareBuild::Clear() {
  warebuild_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckFlushWareBuild::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .HelloKittyMsgData.WareHouseBuildBase warebuild = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_warebuild:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_warebuild()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_warebuild;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckFlushWareBuild::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .HelloKittyMsgData.WareHouseBuildBase warebuild = 1;
  for (int i = 0; i < this->warebuild_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->warebuild(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckFlushWareBuild::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .HelloKittyMsgData.WareHouseBuildBase warebuild = 1;
  for (int i = 0; i < this->warebuild_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->warebuild(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckFlushWareBuild::ByteSize() const {
  int total_size = 0;

  // repeated .HelloKittyMsgData.WareHouseBuildBase warebuild = 1;
  total_size += 1 * this->warebuild_size();
  for (int i = 0; i < this->warebuild_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->warebuild(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckFlushWareBuild::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckFlushWareBuild* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckFlushWareBuild*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckFlushWareBuild::MergeFrom(const AckFlushWareBuild& from) {
  GOOGLE_CHECK_NE(&from, this);
  warebuild_.MergeFrom(from.warebuild_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckFlushWareBuild::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckFlushWareBuild::CopyFrom(const AckFlushWareBuild& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckFlushWareBuild::IsInitialized() const {

  for (int i = 0; i < warebuild_size(); i++) {
    if (!this->warebuild(i).IsInitialized()) return false;
  }
  return true;
}

void AckFlushWareBuild::Swap(AckFlushWareBuild* other) {
  if (other != this) {
    warebuild_.Swap(&other->warebuild_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckFlushWareBuild::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckFlushWareBuild_descriptor_;
  metadata.reflection = AckFlushWareBuild_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AckUpdateWareBuid::kWarebuildFieldNumber;
#endif  // !_MSC_VER

AckUpdateWareBuid::AckUpdateWareBuid()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void AckUpdateWareBuid::InitAsDefaultInstance() {
  warebuild_ = const_cast< ::HelloKittyMsgData::WareHouseBuildBase*>(&::HelloKittyMsgData::WareHouseBuildBase::default_instance());
}

AckUpdateWareBuid::AckUpdateWareBuid(const AckUpdateWareBuid& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void AckUpdateWareBuid::SharedCtor() {
  _cached_size_ = 0;
  warebuild_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AckUpdateWareBuid::~AckUpdateWareBuid() {
  SharedDtor();
}

void AckUpdateWareBuid::SharedDtor() {
  if (this != default_instance_) {
    delete warebuild_;
  }
}

void AckUpdateWareBuid::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AckUpdateWareBuid::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AckUpdateWareBuid_descriptor_;
}

const AckUpdateWareBuid& AckUpdateWareBuid::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_warehouse_2eproto();
  return *default_instance_;
}

AckUpdateWareBuid* AckUpdateWareBuid::default_instance_ = NULL;

AckUpdateWareBuid* AckUpdateWareBuid::New() const {
  return new AckUpdateWareBuid;
}

void AckUpdateWareBuid::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_warebuild()) {
      if (warebuild_ != NULL) warebuild_->::HelloKittyMsgData::WareHouseBuildBase::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AckUpdateWareBuid::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .HelloKittyMsgData.WareHouseBuildBase warebuild = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_warebuild()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void AckUpdateWareBuid::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .HelloKittyMsgData.WareHouseBuildBase warebuild = 1;
  if (has_warebuild()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->warebuild(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* AckUpdateWareBuid::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .HelloKittyMsgData.WareHouseBuildBase warebuild = 1;
  if (has_warebuild()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->warebuild(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int AckUpdateWareBuid::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .HelloKittyMsgData.WareHouseBuildBase warebuild = 1;
    if (has_warebuild()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->warebuild());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AckUpdateWareBuid::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AckUpdateWareBuid* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AckUpdateWareBuid*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AckUpdateWareBuid::MergeFrom(const AckUpdateWareBuid& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_warebuild()) {
      mutable_warebuild()->::HelloKittyMsgData::WareHouseBuildBase::MergeFrom(from.warebuild());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AckUpdateWareBuid::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AckUpdateWareBuid::CopyFrom(const AckUpdateWareBuid& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AckUpdateWareBuid::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_warebuild()) {
    if (!this->warebuild().IsInitialized()) return false;
  }
  return true;
}

void AckUpdateWareBuid::Swap(AckUpdateWareBuid* other) {
  if (other != this) {
    std::swap(warebuild_, other->warebuild_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AckUpdateWareBuid::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AckUpdateWareBuid_descriptor_;
  metadata.reflection = AckUpdateWareBuid_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ReqPayGrid::kGridFieldNumber;
#endif  // !_MSC_VER

ReqPayGrid::ReqPayGrid()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ReqPayGrid::InitAsDefaultInstance() {
}

ReqPayGrid::ReqPayGrid(const ReqPayGrid& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ReqPayGrid::SharedCtor() {
  _cached_size_ = 0;
  grid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ReqPayGrid::~ReqPayGrid() {
  SharedDtor();
}

void ReqPayGrid::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReqPayGrid::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReqPayGrid::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReqPayGrid_descriptor_;
}

const ReqPayGrid& ReqPayGrid::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_warehouse_2eproto();
  return *default_instance_;
}

ReqPayGrid* ReqPayGrid::default_instance_ = NULL;

ReqPayGrid* ReqPayGrid::New() const {
  return new ReqPayGrid;
}

void ReqPayGrid::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    grid_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ReqPayGrid::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 grid = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &grid_)));
          set_has_grid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ReqPayGrid::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required uint32 grid = 1;
  if (has_grid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->grid(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ReqPayGrid::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required uint32 grid = 1;
  if (has_grid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->grid(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ReqPayGrid::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required uint32 grid = 1;
    if (has_grid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->grid());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReqPayGrid::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ReqPayGrid* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ReqPayGrid*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ReqPayGrid::MergeFrom(const ReqPayGrid& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_grid()) {
      set_grid(from.grid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ReqPayGrid::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReqPayGrid::CopyFrom(const ReqPayGrid& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReqPayGrid::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ReqPayGrid::Swap(ReqPayGrid* other) {
  if (other != this) {
    std::swap(grid_, other->grid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ReqPayGrid::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReqPayGrid_descriptor_;
  metadata.reflection = ReqPayGrid_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace HelloKittyMsgData

// @@protoc_insertion_point(global_scope)
