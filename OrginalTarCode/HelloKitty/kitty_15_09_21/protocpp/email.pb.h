// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: email.proto

#ifndef PROTOBUF_email_2eproto__INCLUDED
#define PROTOBUF_email_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "trade.pb.h"
// @@protoc_insertion_point(includes)

namespace HelloKittyMsgData {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_email_2eproto();
void protobuf_AssignDesc_email_2eproto();
void protobuf_ShutdownFile_email_2eproto();

class EmailBase;
class EmailInfo;
class ReqEmail;
class ReqSendEmail;
class AckEmail;
class AckUpdateEmail;
class ReqOpEmail;

enum EmailStatusType {
  Email_Status_Accept = 0,
  Email_Status_Read = 1,
  Email_Status_Delete = 2
};
bool EmailStatusType_IsValid(int value);
const EmailStatusType EmailStatusType_MIN = Email_Status_Accept;
const EmailStatusType EmailStatusType_MAX = Email_Status_Delete;
const int EmailStatusType_ARRAYSIZE = EmailStatusType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmailStatusType_descriptor();
inline const ::std::string& EmailStatusType_Name(EmailStatusType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmailStatusType_descriptor(), value);
}
inline bool EmailStatusType_Parse(
    const ::std::string& name, EmailStatusType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmailStatusType>(
    EmailStatusType_descriptor(), name, value);
}
enum EmailOpType {
  Email_Op_Read = 0,
  Email_Status_Close = 1,
  Email_Op_Get_Item = 2,
  Email_Op_Get_Item_All = 3,
  Email_Op_Delete = 4
};
bool EmailOpType_IsValid(int value);
const EmailOpType EmailOpType_MIN = Email_Op_Read;
const EmailOpType EmailOpType_MAX = Email_Op_Delete;
const int EmailOpType_ARRAYSIZE = EmailOpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EmailOpType_descriptor();
inline const ::std::string& EmailOpType_Name(EmailOpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EmailOpType_descriptor(), value);
}
inline bool EmailOpType_Parse(
    const ::std::string& name, EmailOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EmailOpType>(
    EmailOpType_descriptor(), name, value);
}
// ===================================================================

class EmailBase : public ::google::protobuf::Message {
 public:
  EmailBase();
  virtual ~EmailBase();

  EmailBase(const EmailBase& from);

  inline EmailBase& operator=(const EmailBase& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmailBase& default_instance();

  void Swap(EmailBase* other);

  // implements Message ----------------------------------------------

  EmailBase* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmailBase& from);
  void MergeFrom(const EmailBase& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 accepter = 1;
  inline bool has_accepter() const;
  inline void clear_accepter();
  static const int kAccepterFieldNumber = 1;
  inline ::google::protobuf::uint64 accepter() const;
  inline void set_accepter(::google::protobuf::uint64 value);

  // required string acceptername = 2;
  inline bool has_acceptername() const;
  inline void clear_acceptername();
  static const int kAccepternameFieldNumber = 2;
  inline const ::std::string& acceptername() const;
  inline void set_acceptername(const ::std::string& value);
  inline void set_acceptername(const char* value);
  inline void set_acceptername(const char* value, size_t size);
  inline ::std::string* mutable_acceptername();
  inline ::std::string* release_acceptername();
  inline void set_allocated_acceptername(::std::string* acceptername);

  // required string title = 3;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 3;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // required string conten = 4;
  inline bool has_conten() const;
  inline void clear_conten();
  static const int kContenFieldNumber = 4;
  inline const ::std::string& conten() const;
  inline void set_conten(const ::std::string& value);
  inline void set_conten(const char* value);
  inline void set_conten(const char* value, size_t size);
  inline ::std::string* mutable_conten();
  inline ::std::string* release_conten();
  inline void set_allocated_conten(::std::string* conten);

  // repeated .HelloKittyMsgData.PbStoreItem item = 5;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 5;
  inline const ::HelloKittyMsgData::PbStoreItem& item(int index) const;
  inline ::HelloKittyMsgData::PbStoreItem* mutable_item(int index);
  inline ::HelloKittyMsgData::PbStoreItem* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::PbStoreItem >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::PbStoreItem >*
      mutable_item();

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.EmailBase)
 private:
  inline void set_has_accepter();
  inline void clear_has_accepter();
  inline void set_has_acceptername();
  inline void clear_has_acceptername();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_conten();
  inline void clear_has_conten();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 accepter_;
  ::std::string* acceptername_;
  ::std::string* title_;
  ::std::string* conten_;
  ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::PbStoreItem > item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_email_2eproto();
  friend void protobuf_AssignDesc_email_2eproto();
  friend void protobuf_ShutdownFile_email_2eproto();

  void InitAsDefaultInstance();
  static EmailBase* default_instance_;
};
// -------------------------------------------------------------------

class EmailInfo : public ::google::protobuf::Message {
 public:
  EmailInfo();
  virtual ~EmailInfo();

  EmailInfo(const EmailInfo& from);

  inline EmailInfo& operator=(const EmailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const EmailInfo& default_instance();

  void Swap(EmailInfo* other);

  // implements Message ----------------------------------------------

  EmailInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const EmailInfo& from);
  void MergeFrom(const EmailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required uint64 sender = 2;
  inline bool has_sender() const;
  inline void clear_sender();
  static const int kSenderFieldNumber = 2;
  inline ::google::protobuf::uint64 sender() const;
  inline void set_sender(::google::protobuf::uint64 value);

  // required string sendername = 3;
  inline bool has_sendername() const;
  inline void clear_sendername();
  static const int kSendernameFieldNumber = 3;
  inline const ::std::string& sendername() const;
  inline void set_sendername(const ::std::string& value);
  inline void set_sendername(const char* value);
  inline void set_sendername(const char* value, size_t size);
  inline ::std::string* mutable_sendername();
  inline ::std::string* release_sendername();
  inline void set_allocated_sendername(::std::string* sendername);

  // required .HelloKittyMsgData.EmailBase emailbase = 4;
  inline bool has_emailbase() const;
  inline void clear_emailbase();
  static const int kEmailbaseFieldNumber = 4;
  inline const ::HelloKittyMsgData::EmailBase& emailbase() const;
  inline ::HelloKittyMsgData::EmailBase* mutable_emailbase();
  inline ::HelloKittyMsgData::EmailBase* release_emailbase();
  inline void set_allocated_emailbase(::HelloKittyMsgData::EmailBase* emailbase);

  // required uint64 createtime = 5;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 5;
  inline ::google::protobuf::uint64 createtime() const;
  inline void set_createtime(::google::protobuf::uint64 value);

  // required .HelloKittyMsgData.EmailStatusType status = 6;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 6;
  inline ::HelloKittyMsgData::EmailStatusType status() const;
  inline void set_status(::HelloKittyMsgData::EmailStatusType value);

  // optional bool popup = 7 [default = false];
  inline bool has_popup() const;
  inline void clear_popup();
  static const int kPopupFieldNumber = 7;
  inline bool popup() const;
  inline void set_popup(bool value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.EmailInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_sender();
  inline void clear_has_sender();
  inline void set_has_sendername();
  inline void clear_has_sendername();
  inline void set_has_emailbase();
  inline void clear_has_emailbase();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_popup();
  inline void clear_has_popup();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::google::protobuf::uint64 sender_;
  ::std::string* sendername_;
  ::HelloKittyMsgData::EmailBase* emailbase_;
  ::google::protobuf::uint64 createtime_;
  int status_;
  bool popup_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_email_2eproto();
  friend void protobuf_AssignDesc_email_2eproto();
  friend void protobuf_ShutdownFile_email_2eproto();

  void InitAsDefaultInstance();
  static EmailInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReqEmail : public ::google::protobuf::Message {
 public:
  ReqEmail();
  virtual ~ReqEmail();

  ReqEmail(const ReqEmail& from);

  inline ReqEmail& operator=(const ReqEmail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqEmail& default_instance();

  void Swap(ReqEmail* other);

  // implements Message ----------------------------------------------

  ReqEmail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqEmail& from);
  void MergeFrom(const ReqEmail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1 [default = 0];
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ReqEmail)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_email_2eproto();
  friend void protobuf_AssignDesc_email_2eproto();
  friend void protobuf_ShutdownFile_email_2eproto();

  void InitAsDefaultInstance();
  static ReqEmail* default_instance_;
};
// -------------------------------------------------------------------

class ReqSendEmail : public ::google::protobuf::Message {
 public:
  ReqSendEmail();
  virtual ~ReqSendEmail();

  ReqSendEmail(const ReqSendEmail& from);

  inline ReqSendEmail& operator=(const ReqSendEmail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqSendEmail& default_instance();

  void Swap(ReqSendEmail* other);

  // implements Message ----------------------------------------------

  ReqSendEmail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqSendEmail& from);
  void MergeFrom(const ReqSendEmail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HelloKittyMsgData.EmailBase emailbase = 1;
  inline bool has_emailbase() const;
  inline void clear_emailbase();
  static const int kEmailbaseFieldNumber = 1;
  inline const ::HelloKittyMsgData::EmailBase& emailbase() const;
  inline ::HelloKittyMsgData::EmailBase* mutable_emailbase();
  inline ::HelloKittyMsgData::EmailBase* release_emailbase();
  inline void set_allocated_emailbase(::HelloKittyMsgData::EmailBase* emailbase);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ReqSendEmail)
 private:
  inline void set_has_emailbase();
  inline void clear_has_emailbase();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::HelloKittyMsgData::EmailBase* emailbase_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_email_2eproto();
  friend void protobuf_AssignDesc_email_2eproto();
  friend void protobuf_ShutdownFile_email_2eproto();

  void InitAsDefaultInstance();
  static ReqSendEmail* default_instance_;
};
// -------------------------------------------------------------------

class AckEmail : public ::google::protobuf::Message {
 public:
  AckEmail();
  virtual ~AckEmail();

  AckEmail(const AckEmail& from);

  inline AckEmail& operator=(const AckEmail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckEmail& default_instance();

  void Swap(AckEmail* other);

  // implements Message ----------------------------------------------

  AckEmail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckEmail& from);
  void MergeFrom(const AckEmail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .HelloKittyMsgData.EmailInfo email = 1;
  inline int email_size() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::HelloKittyMsgData::EmailInfo& email(int index) const;
  inline ::HelloKittyMsgData::EmailInfo* mutable_email(int index);
  inline ::HelloKittyMsgData::EmailInfo* add_email();
  inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::EmailInfo >&
      email() const;
  inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::EmailInfo >*
      mutable_email();

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.AckEmail)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::EmailInfo > email_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_email_2eproto();
  friend void protobuf_AssignDesc_email_2eproto();
  friend void protobuf_ShutdownFile_email_2eproto();

  void InitAsDefaultInstance();
  static AckEmail* default_instance_;
};
// -------------------------------------------------------------------

class AckUpdateEmail : public ::google::protobuf::Message {
 public:
  AckUpdateEmail();
  virtual ~AckUpdateEmail();

  AckUpdateEmail(const AckUpdateEmail& from);

  inline AckUpdateEmail& operator=(const AckUpdateEmail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AckUpdateEmail& default_instance();

  void Swap(AckUpdateEmail* other);

  // implements Message ----------------------------------------------

  AckUpdateEmail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AckUpdateEmail& from);
  void MergeFrom(const AckUpdateEmail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HelloKittyMsgData.EmailInfo email = 1;
  inline bool has_email() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 1;
  inline const ::HelloKittyMsgData::EmailInfo& email() const;
  inline ::HelloKittyMsgData::EmailInfo* mutable_email();
  inline ::HelloKittyMsgData::EmailInfo* release_email();
  inline void set_allocated_email(::HelloKittyMsgData::EmailInfo* email);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.AckUpdateEmail)
 private:
  inline void set_has_email();
  inline void clear_has_email();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::HelloKittyMsgData::EmailInfo* email_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_email_2eproto();
  friend void protobuf_AssignDesc_email_2eproto();
  friend void protobuf_ShutdownFile_email_2eproto();

  void InitAsDefaultInstance();
  static AckUpdateEmail* default_instance_;
};
// -------------------------------------------------------------------

class ReqOpEmail : public ::google::protobuf::Message {
 public:
  ReqOpEmail();
  virtual ~ReqOpEmail();

  ReqOpEmail(const ReqOpEmail& from);

  inline ReqOpEmail& operator=(const ReqOpEmail& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReqOpEmail& default_instance();

  void Swap(ReqOpEmail* other);

  // implements Message ----------------------------------------------

  ReqOpEmail* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReqOpEmail& from);
  void MergeFrom(const ReqOpEmail& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // required .HelloKittyMsgData.EmailOpType optype = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOptypeFieldNumber = 2;
  inline ::HelloKittyMsgData::EmailOpType optype() const;
  inline void set_optype(::HelloKittyMsgData::EmailOpType value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ReqOpEmail)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_optype();
  inline void clear_has_optype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_email_2eproto();
  friend void protobuf_AssignDesc_email_2eproto();
  friend void protobuf_ShutdownFile_email_2eproto();

  void InitAsDefaultInstance();
  static ReqOpEmail* default_instance_;
};
// ===================================================================


// ===================================================================

// EmailBase

// required uint64 accepter = 1;
inline bool EmailBase::has_accepter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmailBase::set_has_accepter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmailBase::clear_has_accepter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmailBase::clear_accepter() {
  accepter_ = GOOGLE_ULONGLONG(0);
  clear_has_accepter();
}
inline ::google::protobuf::uint64 EmailBase::accepter() const {
  return accepter_;
}
inline void EmailBase::set_accepter(::google::protobuf::uint64 value) {
  set_has_accepter();
  accepter_ = value;
}

// required string acceptername = 2;
inline bool EmailBase::has_acceptername() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmailBase::set_has_acceptername() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmailBase::clear_has_acceptername() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmailBase::clear_acceptername() {
  if (acceptername_ != &::google::protobuf::internal::kEmptyString) {
    acceptername_->clear();
  }
  clear_has_acceptername();
}
inline const ::std::string& EmailBase::acceptername() const {
  return *acceptername_;
}
inline void EmailBase::set_acceptername(const ::std::string& value) {
  set_has_acceptername();
  if (acceptername_ == &::google::protobuf::internal::kEmptyString) {
    acceptername_ = new ::std::string;
  }
  acceptername_->assign(value);
}
inline void EmailBase::set_acceptername(const char* value) {
  set_has_acceptername();
  if (acceptername_ == &::google::protobuf::internal::kEmptyString) {
    acceptername_ = new ::std::string;
  }
  acceptername_->assign(value);
}
inline void EmailBase::set_acceptername(const char* value, size_t size) {
  set_has_acceptername();
  if (acceptername_ == &::google::protobuf::internal::kEmptyString) {
    acceptername_ = new ::std::string;
  }
  acceptername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmailBase::mutable_acceptername() {
  set_has_acceptername();
  if (acceptername_ == &::google::protobuf::internal::kEmptyString) {
    acceptername_ = new ::std::string;
  }
  return acceptername_;
}
inline ::std::string* EmailBase::release_acceptername() {
  clear_has_acceptername();
  if (acceptername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = acceptername_;
    acceptername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmailBase::set_allocated_acceptername(::std::string* acceptername) {
  if (acceptername_ != &::google::protobuf::internal::kEmptyString) {
    delete acceptername_;
  }
  if (acceptername) {
    set_has_acceptername();
    acceptername_ = acceptername;
  } else {
    clear_has_acceptername();
    acceptername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string title = 3;
inline bool EmailBase::has_title() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmailBase::set_has_title() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmailBase::clear_has_title() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmailBase::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& EmailBase::title() const {
  return *title_;
}
inline void EmailBase::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void EmailBase::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void EmailBase::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmailBase::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* EmailBase::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmailBase::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string conten = 4;
inline bool EmailBase::has_conten() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmailBase::set_has_conten() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmailBase::clear_has_conten() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmailBase::clear_conten() {
  if (conten_ != &::google::protobuf::internal::kEmptyString) {
    conten_->clear();
  }
  clear_has_conten();
}
inline const ::std::string& EmailBase::conten() const {
  return *conten_;
}
inline void EmailBase::set_conten(const ::std::string& value) {
  set_has_conten();
  if (conten_ == &::google::protobuf::internal::kEmptyString) {
    conten_ = new ::std::string;
  }
  conten_->assign(value);
}
inline void EmailBase::set_conten(const char* value) {
  set_has_conten();
  if (conten_ == &::google::protobuf::internal::kEmptyString) {
    conten_ = new ::std::string;
  }
  conten_->assign(value);
}
inline void EmailBase::set_conten(const char* value, size_t size) {
  set_has_conten();
  if (conten_ == &::google::protobuf::internal::kEmptyString) {
    conten_ = new ::std::string;
  }
  conten_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmailBase::mutable_conten() {
  set_has_conten();
  if (conten_ == &::google::protobuf::internal::kEmptyString) {
    conten_ = new ::std::string;
  }
  return conten_;
}
inline ::std::string* EmailBase::release_conten() {
  clear_has_conten();
  if (conten_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = conten_;
    conten_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmailBase::set_allocated_conten(::std::string* conten) {
  if (conten_ != &::google::protobuf::internal::kEmptyString) {
    delete conten_;
  }
  if (conten) {
    set_has_conten();
    conten_ = conten;
  } else {
    clear_has_conten();
    conten_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .HelloKittyMsgData.PbStoreItem item = 5;
inline int EmailBase::item_size() const {
  return item_.size();
}
inline void EmailBase::clear_item() {
  item_.Clear();
}
inline const ::HelloKittyMsgData::PbStoreItem& EmailBase::item(int index) const {
  return item_.Get(index);
}
inline ::HelloKittyMsgData::PbStoreItem* EmailBase::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::HelloKittyMsgData::PbStoreItem* EmailBase::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::PbStoreItem >&
EmailBase::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::PbStoreItem >*
EmailBase::mutable_item() {
  return &item_;
}

// -------------------------------------------------------------------

// EmailInfo

// required uint64 id = 1;
inline bool EmailInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void EmailInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void EmailInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void EmailInfo::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 EmailInfo::id() const {
  return id_;
}
inline void EmailInfo::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required uint64 sender = 2;
inline bool EmailInfo::has_sender() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void EmailInfo::set_has_sender() {
  _has_bits_[0] |= 0x00000002u;
}
inline void EmailInfo::clear_has_sender() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void EmailInfo::clear_sender() {
  sender_ = GOOGLE_ULONGLONG(0);
  clear_has_sender();
}
inline ::google::protobuf::uint64 EmailInfo::sender() const {
  return sender_;
}
inline void EmailInfo::set_sender(::google::protobuf::uint64 value) {
  set_has_sender();
  sender_ = value;
}

// required string sendername = 3;
inline bool EmailInfo::has_sendername() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void EmailInfo::set_has_sendername() {
  _has_bits_[0] |= 0x00000004u;
}
inline void EmailInfo::clear_has_sendername() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void EmailInfo::clear_sendername() {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    sendername_->clear();
  }
  clear_has_sendername();
}
inline const ::std::string& EmailInfo::sendername() const {
  return *sendername_;
}
inline void EmailInfo::set_sendername(const ::std::string& value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void EmailInfo::set_sendername(const char* value) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(value);
}
inline void EmailInfo::set_sendername(const char* value, size_t size) {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  sendername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* EmailInfo::mutable_sendername() {
  set_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    sendername_ = new ::std::string;
  }
  return sendername_;
}
inline ::std::string* EmailInfo::release_sendername() {
  clear_has_sendername();
  if (sendername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sendername_;
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void EmailInfo::set_allocated_sendername(::std::string* sendername) {
  if (sendername_ != &::google::protobuf::internal::kEmptyString) {
    delete sendername_;
  }
  if (sendername) {
    set_has_sendername();
    sendername_ = sendername;
  } else {
    clear_has_sendername();
    sendername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .HelloKittyMsgData.EmailBase emailbase = 4;
inline bool EmailInfo::has_emailbase() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void EmailInfo::set_has_emailbase() {
  _has_bits_[0] |= 0x00000008u;
}
inline void EmailInfo::clear_has_emailbase() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void EmailInfo::clear_emailbase() {
  if (emailbase_ != NULL) emailbase_->::HelloKittyMsgData::EmailBase::Clear();
  clear_has_emailbase();
}
inline const ::HelloKittyMsgData::EmailBase& EmailInfo::emailbase() const {
  return emailbase_ != NULL ? *emailbase_ : *default_instance_->emailbase_;
}
inline ::HelloKittyMsgData::EmailBase* EmailInfo::mutable_emailbase() {
  set_has_emailbase();
  if (emailbase_ == NULL) emailbase_ = new ::HelloKittyMsgData::EmailBase;
  return emailbase_;
}
inline ::HelloKittyMsgData::EmailBase* EmailInfo::release_emailbase() {
  clear_has_emailbase();
  ::HelloKittyMsgData::EmailBase* temp = emailbase_;
  emailbase_ = NULL;
  return temp;
}
inline void EmailInfo::set_allocated_emailbase(::HelloKittyMsgData::EmailBase* emailbase) {
  delete emailbase_;
  emailbase_ = emailbase;
  if (emailbase) {
    set_has_emailbase();
  } else {
    clear_has_emailbase();
  }
}

// required uint64 createtime = 5;
inline bool EmailInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void EmailInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void EmailInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void EmailInfo::clear_createtime() {
  createtime_ = GOOGLE_ULONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::uint64 EmailInfo::createtime() const {
  return createtime_;
}
inline void EmailInfo::set_createtime(::google::protobuf::uint64 value) {
  set_has_createtime();
  createtime_ = value;
}

// required .HelloKittyMsgData.EmailStatusType status = 6;
inline bool EmailInfo::has_status() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void EmailInfo::set_has_status() {
  _has_bits_[0] |= 0x00000020u;
}
inline void EmailInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void EmailInfo::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::HelloKittyMsgData::EmailStatusType EmailInfo::status() const {
  return static_cast< ::HelloKittyMsgData::EmailStatusType >(status_);
}
inline void EmailInfo::set_status(::HelloKittyMsgData::EmailStatusType value) {
  assert(::HelloKittyMsgData::EmailStatusType_IsValid(value));
  set_has_status();
  status_ = value;
}

// optional bool popup = 7 [default = false];
inline bool EmailInfo::has_popup() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void EmailInfo::set_has_popup() {
  _has_bits_[0] |= 0x00000040u;
}
inline void EmailInfo::clear_has_popup() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void EmailInfo::clear_popup() {
  popup_ = false;
  clear_has_popup();
}
inline bool EmailInfo::popup() const {
  return popup_;
}
inline void EmailInfo::set_popup(bool value) {
  set_has_popup();
  popup_ = value;
}

// -------------------------------------------------------------------

// ReqEmail

// optional uint64 id = 1 [default = 0];
inline bool ReqEmail::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqEmail::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqEmail::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqEmail::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 ReqEmail::id() const {
  return id_;
}
inline void ReqEmail::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ReqSendEmail

// required .HelloKittyMsgData.EmailBase emailbase = 1;
inline bool ReqSendEmail::has_emailbase() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqSendEmail::set_has_emailbase() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqSendEmail::clear_has_emailbase() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqSendEmail::clear_emailbase() {
  if (emailbase_ != NULL) emailbase_->::HelloKittyMsgData::EmailBase::Clear();
  clear_has_emailbase();
}
inline const ::HelloKittyMsgData::EmailBase& ReqSendEmail::emailbase() const {
  return emailbase_ != NULL ? *emailbase_ : *default_instance_->emailbase_;
}
inline ::HelloKittyMsgData::EmailBase* ReqSendEmail::mutable_emailbase() {
  set_has_emailbase();
  if (emailbase_ == NULL) emailbase_ = new ::HelloKittyMsgData::EmailBase;
  return emailbase_;
}
inline ::HelloKittyMsgData::EmailBase* ReqSendEmail::release_emailbase() {
  clear_has_emailbase();
  ::HelloKittyMsgData::EmailBase* temp = emailbase_;
  emailbase_ = NULL;
  return temp;
}
inline void ReqSendEmail::set_allocated_emailbase(::HelloKittyMsgData::EmailBase* emailbase) {
  delete emailbase_;
  emailbase_ = emailbase;
  if (emailbase) {
    set_has_emailbase();
  } else {
    clear_has_emailbase();
  }
}

// -------------------------------------------------------------------

// AckEmail

// repeated .HelloKittyMsgData.EmailInfo email = 1;
inline int AckEmail::email_size() const {
  return email_.size();
}
inline void AckEmail::clear_email() {
  email_.Clear();
}
inline const ::HelloKittyMsgData::EmailInfo& AckEmail::email(int index) const {
  return email_.Get(index);
}
inline ::HelloKittyMsgData::EmailInfo* AckEmail::mutable_email(int index) {
  return email_.Mutable(index);
}
inline ::HelloKittyMsgData::EmailInfo* AckEmail::add_email() {
  return email_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::EmailInfo >&
AckEmail::email() const {
  return email_;
}
inline ::google::protobuf::RepeatedPtrField< ::HelloKittyMsgData::EmailInfo >*
AckEmail::mutable_email() {
  return &email_;
}

// -------------------------------------------------------------------

// AckUpdateEmail

// required .HelloKittyMsgData.EmailInfo email = 1;
inline bool AckUpdateEmail::has_email() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AckUpdateEmail::set_has_email() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AckUpdateEmail::clear_has_email() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AckUpdateEmail::clear_email() {
  if (email_ != NULL) email_->::HelloKittyMsgData::EmailInfo::Clear();
  clear_has_email();
}
inline const ::HelloKittyMsgData::EmailInfo& AckUpdateEmail::email() const {
  return email_ != NULL ? *email_ : *default_instance_->email_;
}
inline ::HelloKittyMsgData::EmailInfo* AckUpdateEmail::mutable_email() {
  set_has_email();
  if (email_ == NULL) email_ = new ::HelloKittyMsgData::EmailInfo;
  return email_;
}
inline ::HelloKittyMsgData::EmailInfo* AckUpdateEmail::release_email() {
  clear_has_email();
  ::HelloKittyMsgData::EmailInfo* temp = email_;
  email_ = NULL;
  return temp;
}
inline void AckUpdateEmail::set_allocated_email(::HelloKittyMsgData::EmailInfo* email) {
  delete email_;
  email_ = email;
  if (email) {
    set_has_email();
  } else {
    clear_has_email();
  }
}

// -------------------------------------------------------------------

// ReqOpEmail

// required uint64 id = 1;
inline bool ReqOpEmail::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReqOpEmail::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReqOpEmail::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReqOpEmail::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 ReqOpEmail::id() const {
  return id_;
}
inline void ReqOpEmail::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// required .HelloKittyMsgData.EmailOpType optype = 2;
inline bool ReqOpEmail::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReqOpEmail::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReqOpEmail::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReqOpEmail::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::HelloKittyMsgData::EmailOpType ReqOpEmail::optype() const {
  return static_cast< ::HelloKittyMsgData::EmailOpType >(optype_);
}
inline void ReqOpEmail::set_optype(::HelloKittyMsgData::EmailOpType value) {
  assert(::HelloKittyMsgData::EmailOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace HelloKittyMsgData

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::EmailStatusType>() {
  return ::HelloKittyMsgData::EmailStatusType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::EmailOpType>() {
  return ::HelloKittyMsgData::EmailOpType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_email_2eproto__INCLUDED
