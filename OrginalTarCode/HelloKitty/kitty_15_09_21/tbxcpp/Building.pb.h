// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Building.proto

#ifndef PROTOBUF_Building_2eproto__INCLUDED
#define PROTOBUF_Building_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_Building_2eproto();
void protobuf_AssignDesc_Building_2eproto();
void protobuf_ShutdownFile_Building_2eproto();

class building;
class building_t_building;
class newRoleAttr;
class newRoleAttr_t_newRoleAttr;

// ===================================================================

class building_t_building : public ::google::protobuf::Message {
 public:
  building_t_building();
  virtual ~building_t_building();

  building_t_building(const building_t_building& from);

  inline building_t_building& operator=(const building_t_building& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const building_t_building& default_instance();

  void Swap(building_t_building* other);

  // implements Message ----------------------------------------------

  building_t_building* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const building_t_building& from);
  void MergeFrom(const building_t_building& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 tbxid = 1;
  inline bool has_tbxid() const;
  inline void clear_tbxid();
  static const int kTbxidFieldNumber = 1;
  inline ::google::protobuf::uint32 tbxid() const;
  inline void set_tbxid(::google::protobuf::uint32 value);

  // required uint32 dependID = 2;
  inline bool has_dependid() const;
  inline void clear_dependid();
  static const int kDependIDFieldNumber = 2;
  inline ::google::protobuf::uint32 dependid() const;
  inline void set_dependid(::google::protobuf::uint32 value);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 MaxCap = 5;
  inline bool has_maxcap() const;
  inline void clear_maxcap();
  static const int kMaxCapFieldNumber = 5;
  inline ::google::protobuf::uint32 maxcap() const;
  inline void set_maxcap(::google::protobuf::uint32 value);

  // required uint32 GuestProduce = 6;
  inline bool has_guestproduce() const;
  inline void clear_guestproduce();
  static const int kGuestProduceFieldNumber = 6;
  inline ::google::protobuf::uint32 guestproduce() const;
  inline void set_guestproduce(::google::protobuf::uint32 value);

  // required string buildGridInfo = 7;
  inline bool has_buildgridinfo() const;
  inline void clear_buildgridinfo();
  static const int kBuildGridInfoFieldNumber = 7;
  inline const ::std::string& buildgridinfo() const;
  inline void set_buildgridinfo(const ::std::string& value);
  inline void set_buildgridinfo(const char* value);
  inline void set_buildgridinfo(const char* value, size_t size);
  inline ::std::string* mutable_buildgridinfo();
  inline ::std::string* release_buildgridinfo();
  inline void set_allocated_buildgridinfo(::std::string* buildgridinfo);

  // required uint32 infoType = 8;
  inline bool has_infotype() const;
  inline void clear_infotype();
  static const int kInfoTypeFieldNumber = 8;
  inline ::google::protobuf::uint32 infotype() const;
  inline void set_infotype(::google::protobuf::uint32 value);

  // required string buildSpineRes = 9;
  inline bool has_buildspineres() const;
  inline void clear_buildspineres();
  static const int kBuildSpineResFieldNumber = 9;
  inline const ::std::string& buildspineres() const;
  inline void set_buildspineres(const ::std::string& value);
  inline void set_buildspineres(const char* value);
  inline void set_buildspineres(const char* value, size_t size);
  inline ::std::string* mutable_buildspineres();
  inline ::std::string* release_buildspineres();
  inline void set_allocated_buildspineres(::std::string* buildspineres);

  // required uint32 buildKind = 10;
  inline bool has_buildkind() const;
  inline void clear_buildkind();
  static const int kBuildKindFieldNumber = 10;
  inline ::google::protobuf::uint32 buildkind() const;
  inline void set_buildkind(::google::protobuf::uint32 value);

  // required string premiseBuild = 11;
  inline bool has_premisebuild() const;
  inline void clear_premisebuild();
  static const int kPremiseBuildFieldNumber = 11;
  inline const ::std::string& premisebuild() const;
  inline void set_premisebuild(const ::std::string& value);
  inline void set_premisebuild(const char* value);
  inline void set_premisebuild(const char* value, size_t size);
  inline ::std::string* mutable_premisebuild();
  inline ::std::string* release_premisebuild();
  inline void set_allocated_premisebuild(::std::string* premisebuild);

  // required string effectPic = 12;
  inline bool has_effectpic() const;
  inline void clear_effectpic();
  static const int kEffectPicFieldNumber = 12;
  inline const ::std::string& effectpic() const;
  inline void set_effectpic(const ::std::string& value);
  inline void set_effectpic(const char* value);
  inline void set_effectpic(const char* value, size_t size);
  inline ::std::string* mutable_effectpic();
  inline ::std::string* release_effectpic();
  inline void set_allocated_effectpic(::std::string* effectpic);

  // required string effectRange = 13;
  inline bool has_effectrange() const;
  inline void clear_effectrange();
  static const int kEffectRangeFieldNumber = 13;
  inline const ::std::string& effectrange() const;
  inline void set_effectrange(const ::std::string& value);
  inline void set_effectrange(const char* value);
  inline void set_effectrange(const char* value, size_t size);
  inline ::std::string* mutable_effectrange();
  inline ::std::string* release_effectrange();
  inline void set_allocated_effectrange(::std::string* effectrange);

  // required uint32 RoadActiveType = 14;
  inline bool has_roadactivetype() const;
  inline void clear_roadactivetype();
  static const int kRoadActiveTypeFieldNumber = 14;
  inline ::google::protobuf::uint32 roadactivetype() const;
  inline void set_roadactivetype(::google::protobuf::uint32 value);

  // required uint32 guestReduce = 15;
  inline bool has_guestreduce() const;
  inline void clear_guestreduce();
  static const int kGuestReduceFieldNumber = 15;
  inline ::google::protobuf::uint32 guestreduce() const;
  inline void set_guestreduce(::google::protobuf::uint32 value);

  // required double happyIncrease = 16;
  inline bool has_happyincrease() const;
  inline void clear_happyincrease();
  static const int kHappyIncreaseFieldNumber = 16;
  inline double happyincrease() const;
  inline void set_happyincrease(double value);

  // required uint32 sellTime = 17;
  inline bool has_selltime() const;
  inline void clear_selltime();
  static const int kSellTimeFieldNumber = 17;
  inline ::google::protobuf::uint32 selltime() const;
  inline void set_selltime(::google::protobuf::uint32 value);

  // required uint32 merriness = 18;
  inline bool has_merriness() const;
  inline void clear_merriness();
  static const int kMerrinessFieldNumber = 18;
  inline ::google::protobuf::uint32 merriness() const;
  inline void set_merriness(::google::protobuf::uint32 value);

  // required uint32 requireGold = 19;
  inline bool has_requiregold() const;
  inline void clear_requiregold();
  static const int kRequireGoldFieldNumber = 19;
  inline ::google::protobuf::uint32 requiregold() const;
  inline void set_requiregold(::google::protobuf::uint32 value);

  // required string requireItem = 20;
  inline bool has_requireitem() const;
  inline void clear_requireitem();
  static const int kRequireItemFieldNumber = 20;
  inline const ::std::string& requireitem() const;
  inline void set_requireitem(const ::std::string& value);
  inline void set_requireitem(const char* value);
  inline void set_requireitem(const char* value, size_t size);
  inline ::std::string* mutable_requireitem();
  inline ::std::string* release_requireitem();
  inline void set_allocated_requireitem(::std::string* requireitem);

  // required uint32 GoldOutput = 21;
  inline bool has_goldoutput() const;
  inline void clear_goldoutput();
  static const int kGoldOutputFieldNumber = 21;
  inline ::google::protobuf::uint32 goldoutput() const;
  inline void set_goldoutput(::google::protobuf::uint32 value);

  // required uint32 GoldOutputMax = 22;
  inline bool has_goldoutputmax() const;
  inline void clear_goldoutputmax();
  static const int kGoldOutputMaxFieldNumber = 22;
  inline ::google::protobuf::uint32 goldoutputmax() const;
  inline void set_goldoutputmax(::google::protobuf::uint32 value);

  // required uint32 makeTime = 23;
  inline bool has_maketime() const;
  inline void clear_maketime();
  static const int kMakeTimeFieldNumber = 23;
  inline ::google::protobuf::uint32 maketime() const;
  inline void set_maketime(::google::protobuf::uint32 value);

  // required uint32 time = 24;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 24;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required string effectval = 25;
  inline bool has_effectval() const;
  inline void clear_effectval();
  static const int kEffectvalFieldNumber = 25;
  inline const ::std::string& effectval() const;
  inline void set_effectval(const ::std::string& value);
  inline void set_effectval(const char* value);
  inline void set_effectval(const char* value, size_t size);
  inline ::std::string* mutable_effectval();
  inline ::std::string* release_effectval();
  inline void set_allocated_effectval(::std::string* effectval);

  // required string personRequire = 26;
  inline bool has_personrequire() const;
  inline void clear_personrequire();
  static const int kPersonRequireFieldNumber = 26;
  inline const ::std::string& personrequire() const;
  inline void set_personrequire(const ::std::string& value);
  inline void set_personrequire(const char* value);
  inline void set_personrequire(const char* value, size_t size);
  inline ::std::string* mutable_personrequire();
  inline ::std::string* release_personrequire();
  inline void set_allocated_personrequire(::std::string* personrequire);

  // required string iconPic = 27;
  inline bool has_iconpic() const;
  inline void clear_iconpic();
  static const int kIconPicFieldNumber = 27;
  inline const ::std::string& iconpic() const;
  inline void set_iconpic(const ::std::string& value);
  inline void set_iconpic(const char* value);
  inline void set_iconpic(const char* value, size_t size);
  inline ::std::string* mutable_iconpic();
  inline ::std::string* release_iconpic();
  inline void set_allocated_iconpic(::std::string* iconpic);

  // required string description = 28;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 28;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // required string usecard = 29;
  inline bool has_usecard() const;
  inline void clear_usecard();
  static const int kUsecardFieldNumber = 29;
  inline const ::std::string& usecard() const;
  inline void set_usecard(const ::std::string& value);
  inline void set_usecard(const char* value);
  inline void set_usecard(const char* value, size_t size);
  inline ::std::string* mutable_usecard();
  inline ::std::string* release_usecard();
  inline void set_allocated_usecard(::std::string* usecard);

  // @@protoc_insertion_point(class_scope:pb.building.t_building)
 private:
  inline void set_has_tbxid();
  inline void clear_has_tbxid();
  inline void set_has_dependid();
  inline void clear_has_dependid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_maxcap();
  inline void clear_has_maxcap();
  inline void set_has_guestproduce();
  inline void clear_has_guestproduce();
  inline void set_has_buildgridinfo();
  inline void clear_has_buildgridinfo();
  inline void set_has_infotype();
  inline void clear_has_infotype();
  inline void set_has_buildspineres();
  inline void clear_has_buildspineres();
  inline void set_has_buildkind();
  inline void clear_has_buildkind();
  inline void set_has_premisebuild();
  inline void clear_has_premisebuild();
  inline void set_has_effectpic();
  inline void clear_has_effectpic();
  inline void set_has_effectrange();
  inline void clear_has_effectrange();
  inline void set_has_roadactivetype();
  inline void clear_has_roadactivetype();
  inline void set_has_guestreduce();
  inline void clear_has_guestreduce();
  inline void set_has_happyincrease();
  inline void clear_has_happyincrease();
  inline void set_has_selltime();
  inline void clear_has_selltime();
  inline void set_has_merriness();
  inline void clear_has_merriness();
  inline void set_has_requiregold();
  inline void clear_has_requiregold();
  inline void set_has_requireitem();
  inline void clear_has_requireitem();
  inline void set_has_goldoutput();
  inline void clear_has_goldoutput();
  inline void set_has_goldoutputmax();
  inline void clear_has_goldoutputmax();
  inline void set_has_maketime();
  inline void clear_has_maketime();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_effectval();
  inline void clear_has_effectval();
  inline void set_has_personrequire();
  inline void clear_has_personrequire();
  inline void set_has_iconpic();
  inline void clear_has_iconpic();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_usecard();
  inline void clear_has_usecard();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tbxid_;
  ::google::protobuf::uint32 dependid_;
  ::std::string* name_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 maxcap_;
  ::std::string* buildgridinfo_;
  ::google::protobuf::uint32 guestproduce_;
  ::google::protobuf::uint32 infotype_;
  ::std::string* buildspineres_;
  ::std::string* premisebuild_;
  ::std::string* effectpic_;
  ::google::protobuf::uint32 buildkind_;
  ::google::protobuf::uint32 roadactivetype_;
  ::std::string* effectrange_;
  double happyincrease_;
  ::google::protobuf::uint32 guestreduce_;
  ::google::protobuf::uint32 selltime_;
  ::google::protobuf::uint32 merriness_;
  ::google::protobuf::uint32 requiregold_;
  ::std::string* requireitem_;
  ::google::protobuf::uint32 goldoutput_;
  ::google::protobuf::uint32 goldoutputmax_;
  ::google::protobuf::uint32 maketime_;
  ::google::protobuf::uint32 time_;
  ::std::string* effectval_;
  ::std::string* personrequire_;
  ::std::string* iconpic_;
  ::std::string* description_;
  ::std::string* usecard_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];

  friend void  protobuf_AddDesc_Building_2eproto();
  friend void protobuf_AssignDesc_Building_2eproto();
  friend void protobuf_ShutdownFile_Building_2eproto();

  void InitAsDefaultInstance();
  static building_t_building* default_instance_;
};
// -------------------------------------------------------------------

class building : public ::google::protobuf::Message {
 public:
  building();
  virtual ~building();

  building(const building& from);

  inline building& operator=(const building& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const building& default_instance();

  void Swap(building* other);

  // implements Message ----------------------------------------------

  building* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const building& from);
  void MergeFrom(const building& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef building_t_building t_building;

  // accessors -------------------------------------------------------

  // repeated .pb.building.t_building datas = 1;
  inline int datas_size() const;
  inline void clear_datas();
  static const int kDatasFieldNumber = 1;
  inline const ::pb::building_t_building& datas(int index) const;
  inline ::pb::building_t_building* mutable_datas(int index);
  inline ::pb::building_t_building* add_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::building_t_building >&
      datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::building_t_building >*
      mutable_datas();

  // @@protoc_insertion_point(class_scope:pb.building)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::building_t_building > datas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Building_2eproto();
  friend void protobuf_AssignDesc_Building_2eproto();
  friend void protobuf_ShutdownFile_Building_2eproto();

  void InitAsDefaultInstance();
  static building* default_instance_;
};
// -------------------------------------------------------------------

class newRoleAttr_t_newRoleAttr : public ::google::protobuf::Message {
 public:
  newRoleAttr_t_newRoleAttr();
  virtual ~newRoleAttr_t_newRoleAttr();

  newRoleAttr_t_newRoleAttr(const newRoleAttr_t_newRoleAttr& from);

  inline newRoleAttr_t_newRoleAttr& operator=(const newRoleAttr_t_newRoleAttr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const newRoleAttr_t_newRoleAttr& default_instance();

  void Swap(newRoleAttr_t_newRoleAttr* other);

  // implements Message ----------------------------------------------

  newRoleAttr_t_newRoleAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const newRoleAttr_t_newRoleAttr& from);
  void MergeFrom(const newRoleAttr_t_newRoleAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 tbxid = 1;
  inline bool has_tbxid() const;
  inline void clear_tbxid();
  static const int kTbxidFieldNumber = 1;
  inline ::google::protobuf::uint32 tbxid() const;
  inline void set_tbxid(::google::protobuf::uint32 value);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 level = 3;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required string initbuild = 4;
  inline bool has_initbuild() const;
  inline void clear_initbuild();
  static const int kInitbuildFieldNumber = 4;
  inline const ::std::string& initbuild() const;
  inline void set_initbuild(const ::std::string& value);
  inline void set_initbuild(const char* value);
  inline void set_initbuild(const char* value, size_t size);
  inline ::std::string* mutable_initbuild();
  inline ::std::string* release_initbuild();
  inline void set_allocated_initbuild(::std::string* initbuild);

  // required string inititem = 5;
  inline bool has_inititem() const;
  inline void clear_inititem();
  static const int kInititemFieldNumber = 5;
  inline const ::std::string& inititem() const;
  inline void set_inititem(const ::std::string& value);
  inline void set_inititem(const char* value);
  inline void set_inititem(const char* value, size_t size);
  inline ::std::string* mutable_inititem();
  inline ::std::string* release_inititem();
  inline void set_allocated_inititem(::std::string* inititem);

  // @@protoc_insertion_point(class_scope:pb.newRoleAttr.t_newRoleAttr)
 private:
  inline void set_has_tbxid();
  inline void clear_has_tbxid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_initbuild();
  inline void clear_has_initbuild();
  inline void set_has_inititem();
  inline void clear_has_inititem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tbxid_;
  ::google::protobuf::uint32 id_;
  ::std::string* initbuild_;
  ::std::string* inititem_;
  ::google::protobuf::uint32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_Building_2eproto();
  friend void protobuf_AssignDesc_Building_2eproto();
  friend void protobuf_ShutdownFile_Building_2eproto();

  void InitAsDefaultInstance();
  static newRoleAttr_t_newRoleAttr* default_instance_;
};
// -------------------------------------------------------------------

class newRoleAttr : public ::google::protobuf::Message {
 public:
  newRoleAttr();
  virtual ~newRoleAttr();

  newRoleAttr(const newRoleAttr& from);

  inline newRoleAttr& operator=(const newRoleAttr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const newRoleAttr& default_instance();

  void Swap(newRoleAttr* other);

  // implements Message ----------------------------------------------

  newRoleAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const newRoleAttr& from);
  void MergeFrom(const newRoleAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef newRoleAttr_t_newRoleAttr t_newRoleAttr;

  // accessors -------------------------------------------------------

  // repeated .pb.newRoleAttr.t_newRoleAttr datas = 1;
  inline int datas_size() const;
  inline void clear_datas();
  static const int kDatasFieldNumber = 1;
  inline const ::pb::newRoleAttr_t_newRoleAttr& datas(int index) const;
  inline ::pb::newRoleAttr_t_newRoleAttr* mutable_datas(int index);
  inline ::pb::newRoleAttr_t_newRoleAttr* add_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::newRoleAttr_t_newRoleAttr >&
      datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::newRoleAttr_t_newRoleAttr >*
      mutable_datas();

  // @@protoc_insertion_point(class_scope:pb.newRoleAttr)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::newRoleAttr_t_newRoleAttr > datas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_Building_2eproto();
  friend void protobuf_AssignDesc_Building_2eproto();
  friend void protobuf_ShutdownFile_Building_2eproto();

  void InitAsDefaultInstance();
  static newRoleAttr* default_instance_;
};
// ===================================================================


// ===================================================================

// building_t_building

// required uint32 tbxid = 1;
inline bool building_t_building::has_tbxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void building_t_building::set_has_tbxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void building_t_building::clear_has_tbxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void building_t_building::clear_tbxid() {
  tbxid_ = 0u;
  clear_has_tbxid();
}
inline ::google::protobuf::uint32 building_t_building::tbxid() const {
  return tbxid_;
}
inline void building_t_building::set_tbxid(::google::protobuf::uint32 value) {
  set_has_tbxid();
  tbxid_ = value;
}

// required uint32 dependID = 2;
inline bool building_t_building::has_dependid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void building_t_building::set_has_dependid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void building_t_building::clear_has_dependid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void building_t_building::clear_dependid() {
  dependid_ = 0u;
  clear_has_dependid();
}
inline ::google::protobuf::uint32 building_t_building::dependid() const {
  return dependid_;
}
inline void building_t_building::set_dependid(::google::protobuf::uint32 value) {
  set_has_dependid();
  dependid_ = value;
}

// required string name = 3;
inline bool building_t_building::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void building_t_building::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void building_t_building::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void building_t_building::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& building_t_building::name() const {
  return *name_;
}
inline void building_t_building::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void building_t_building::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void building_t_building::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* building_t_building::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 level = 4;
inline bool building_t_building::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void building_t_building::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void building_t_building::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void building_t_building::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 building_t_building::level() const {
  return level_;
}
inline void building_t_building::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 MaxCap = 5;
inline bool building_t_building::has_maxcap() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void building_t_building::set_has_maxcap() {
  _has_bits_[0] |= 0x00000010u;
}
inline void building_t_building::clear_has_maxcap() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void building_t_building::clear_maxcap() {
  maxcap_ = 0u;
  clear_has_maxcap();
}
inline ::google::protobuf::uint32 building_t_building::maxcap() const {
  return maxcap_;
}
inline void building_t_building::set_maxcap(::google::protobuf::uint32 value) {
  set_has_maxcap();
  maxcap_ = value;
}

// required uint32 GuestProduce = 6;
inline bool building_t_building::has_guestproduce() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void building_t_building::set_has_guestproduce() {
  _has_bits_[0] |= 0x00000020u;
}
inline void building_t_building::clear_has_guestproduce() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void building_t_building::clear_guestproduce() {
  guestproduce_ = 0u;
  clear_has_guestproduce();
}
inline ::google::protobuf::uint32 building_t_building::guestproduce() const {
  return guestproduce_;
}
inline void building_t_building::set_guestproduce(::google::protobuf::uint32 value) {
  set_has_guestproduce();
  guestproduce_ = value;
}

// required string buildGridInfo = 7;
inline bool building_t_building::has_buildgridinfo() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void building_t_building::set_has_buildgridinfo() {
  _has_bits_[0] |= 0x00000040u;
}
inline void building_t_building::clear_has_buildgridinfo() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void building_t_building::clear_buildgridinfo() {
  if (buildgridinfo_ != &::google::protobuf::internal::kEmptyString) {
    buildgridinfo_->clear();
  }
  clear_has_buildgridinfo();
}
inline const ::std::string& building_t_building::buildgridinfo() const {
  return *buildgridinfo_;
}
inline void building_t_building::set_buildgridinfo(const ::std::string& value) {
  set_has_buildgridinfo();
  if (buildgridinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildgridinfo_ = new ::std::string;
  }
  buildgridinfo_->assign(value);
}
inline void building_t_building::set_buildgridinfo(const char* value) {
  set_has_buildgridinfo();
  if (buildgridinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildgridinfo_ = new ::std::string;
  }
  buildgridinfo_->assign(value);
}
inline void building_t_building::set_buildgridinfo(const char* value, size_t size) {
  set_has_buildgridinfo();
  if (buildgridinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildgridinfo_ = new ::std::string;
  }
  buildgridinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_buildgridinfo() {
  set_has_buildgridinfo();
  if (buildgridinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildgridinfo_ = new ::std::string;
  }
  return buildgridinfo_;
}
inline ::std::string* building_t_building::release_buildgridinfo() {
  clear_has_buildgridinfo();
  if (buildgridinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buildgridinfo_;
    buildgridinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_buildgridinfo(::std::string* buildgridinfo) {
  if (buildgridinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete buildgridinfo_;
  }
  if (buildgridinfo) {
    set_has_buildgridinfo();
    buildgridinfo_ = buildgridinfo;
  } else {
    clear_has_buildgridinfo();
    buildgridinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 infoType = 8;
inline bool building_t_building::has_infotype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void building_t_building::set_has_infotype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void building_t_building::clear_has_infotype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void building_t_building::clear_infotype() {
  infotype_ = 0u;
  clear_has_infotype();
}
inline ::google::protobuf::uint32 building_t_building::infotype() const {
  return infotype_;
}
inline void building_t_building::set_infotype(::google::protobuf::uint32 value) {
  set_has_infotype();
  infotype_ = value;
}

// required string buildSpineRes = 9;
inline bool building_t_building::has_buildspineres() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void building_t_building::set_has_buildspineres() {
  _has_bits_[0] |= 0x00000100u;
}
inline void building_t_building::clear_has_buildspineres() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void building_t_building::clear_buildspineres() {
  if (buildspineres_ != &::google::protobuf::internal::kEmptyString) {
    buildspineres_->clear();
  }
  clear_has_buildspineres();
}
inline const ::std::string& building_t_building::buildspineres() const {
  return *buildspineres_;
}
inline void building_t_building::set_buildspineres(const ::std::string& value) {
  set_has_buildspineres();
  if (buildspineres_ == &::google::protobuf::internal::kEmptyString) {
    buildspineres_ = new ::std::string;
  }
  buildspineres_->assign(value);
}
inline void building_t_building::set_buildspineres(const char* value) {
  set_has_buildspineres();
  if (buildspineres_ == &::google::protobuf::internal::kEmptyString) {
    buildspineres_ = new ::std::string;
  }
  buildspineres_->assign(value);
}
inline void building_t_building::set_buildspineres(const char* value, size_t size) {
  set_has_buildspineres();
  if (buildspineres_ == &::google::protobuf::internal::kEmptyString) {
    buildspineres_ = new ::std::string;
  }
  buildspineres_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_buildspineres() {
  set_has_buildspineres();
  if (buildspineres_ == &::google::protobuf::internal::kEmptyString) {
    buildspineres_ = new ::std::string;
  }
  return buildspineres_;
}
inline ::std::string* building_t_building::release_buildspineres() {
  clear_has_buildspineres();
  if (buildspineres_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buildspineres_;
    buildspineres_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_buildspineres(::std::string* buildspineres) {
  if (buildspineres_ != &::google::protobuf::internal::kEmptyString) {
    delete buildspineres_;
  }
  if (buildspineres) {
    set_has_buildspineres();
    buildspineres_ = buildspineres;
  } else {
    clear_has_buildspineres();
    buildspineres_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 buildKind = 10;
inline bool building_t_building::has_buildkind() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void building_t_building::set_has_buildkind() {
  _has_bits_[0] |= 0x00000200u;
}
inline void building_t_building::clear_has_buildkind() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void building_t_building::clear_buildkind() {
  buildkind_ = 0u;
  clear_has_buildkind();
}
inline ::google::protobuf::uint32 building_t_building::buildkind() const {
  return buildkind_;
}
inline void building_t_building::set_buildkind(::google::protobuf::uint32 value) {
  set_has_buildkind();
  buildkind_ = value;
}

// required string premiseBuild = 11;
inline bool building_t_building::has_premisebuild() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void building_t_building::set_has_premisebuild() {
  _has_bits_[0] |= 0x00000400u;
}
inline void building_t_building::clear_has_premisebuild() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void building_t_building::clear_premisebuild() {
  if (premisebuild_ != &::google::protobuf::internal::kEmptyString) {
    premisebuild_->clear();
  }
  clear_has_premisebuild();
}
inline const ::std::string& building_t_building::premisebuild() const {
  return *premisebuild_;
}
inline void building_t_building::set_premisebuild(const ::std::string& value) {
  set_has_premisebuild();
  if (premisebuild_ == &::google::protobuf::internal::kEmptyString) {
    premisebuild_ = new ::std::string;
  }
  premisebuild_->assign(value);
}
inline void building_t_building::set_premisebuild(const char* value) {
  set_has_premisebuild();
  if (premisebuild_ == &::google::protobuf::internal::kEmptyString) {
    premisebuild_ = new ::std::string;
  }
  premisebuild_->assign(value);
}
inline void building_t_building::set_premisebuild(const char* value, size_t size) {
  set_has_premisebuild();
  if (premisebuild_ == &::google::protobuf::internal::kEmptyString) {
    premisebuild_ = new ::std::string;
  }
  premisebuild_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_premisebuild() {
  set_has_premisebuild();
  if (premisebuild_ == &::google::protobuf::internal::kEmptyString) {
    premisebuild_ = new ::std::string;
  }
  return premisebuild_;
}
inline ::std::string* building_t_building::release_premisebuild() {
  clear_has_premisebuild();
  if (premisebuild_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = premisebuild_;
    premisebuild_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_premisebuild(::std::string* premisebuild) {
  if (premisebuild_ != &::google::protobuf::internal::kEmptyString) {
    delete premisebuild_;
  }
  if (premisebuild) {
    set_has_premisebuild();
    premisebuild_ = premisebuild;
  } else {
    clear_has_premisebuild();
    premisebuild_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string effectPic = 12;
inline bool building_t_building::has_effectpic() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void building_t_building::set_has_effectpic() {
  _has_bits_[0] |= 0x00000800u;
}
inline void building_t_building::clear_has_effectpic() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void building_t_building::clear_effectpic() {
  if (effectpic_ != &::google::protobuf::internal::kEmptyString) {
    effectpic_->clear();
  }
  clear_has_effectpic();
}
inline const ::std::string& building_t_building::effectpic() const {
  return *effectpic_;
}
inline void building_t_building::set_effectpic(const ::std::string& value) {
  set_has_effectpic();
  if (effectpic_ == &::google::protobuf::internal::kEmptyString) {
    effectpic_ = new ::std::string;
  }
  effectpic_->assign(value);
}
inline void building_t_building::set_effectpic(const char* value) {
  set_has_effectpic();
  if (effectpic_ == &::google::protobuf::internal::kEmptyString) {
    effectpic_ = new ::std::string;
  }
  effectpic_->assign(value);
}
inline void building_t_building::set_effectpic(const char* value, size_t size) {
  set_has_effectpic();
  if (effectpic_ == &::google::protobuf::internal::kEmptyString) {
    effectpic_ = new ::std::string;
  }
  effectpic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_effectpic() {
  set_has_effectpic();
  if (effectpic_ == &::google::protobuf::internal::kEmptyString) {
    effectpic_ = new ::std::string;
  }
  return effectpic_;
}
inline ::std::string* building_t_building::release_effectpic() {
  clear_has_effectpic();
  if (effectpic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effectpic_;
    effectpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_effectpic(::std::string* effectpic) {
  if (effectpic_ != &::google::protobuf::internal::kEmptyString) {
    delete effectpic_;
  }
  if (effectpic) {
    set_has_effectpic();
    effectpic_ = effectpic;
  } else {
    clear_has_effectpic();
    effectpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string effectRange = 13;
inline bool building_t_building::has_effectrange() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void building_t_building::set_has_effectrange() {
  _has_bits_[0] |= 0x00001000u;
}
inline void building_t_building::clear_has_effectrange() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void building_t_building::clear_effectrange() {
  if (effectrange_ != &::google::protobuf::internal::kEmptyString) {
    effectrange_->clear();
  }
  clear_has_effectrange();
}
inline const ::std::string& building_t_building::effectrange() const {
  return *effectrange_;
}
inline void building_t_building::set_effectrange(const ::std::string& value) {
  set_has_effectrange();
  if (effectrange_ == &::google::protobuf::internal::kEmptyString) {
    effectrange_ = new ::std::string;
  }
  effectrange_->assign(value);
}
inline void building_t_building::set_effectrange(const char* value) {
  set_has_effectrange();
  if (effectrange_ == &::google::protobuf::internal::kEmptyString) {
    effectrange_ = new ::std::string;
  }
  effectrange_->assign(value);
}
inline void building_t_building::set_effectrange(const char* value, size_t size) {
  set_has_effectrange();
  if (effectrange_ == &::google::protobuf::internal::kEmptyString) {
    effectrange_ = new ::std::string;
  }
  effectrange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_effectrange() {
  set_has_effectrange();
  if (effectrange_ == &::google::protobuf::internal::kEmptyString) {
    effectrange_ = new ::std::string;
  }
  return effectrange_;
}
inline ::std::string* building_t_building::release_effectrange() {
  clear_has_effectrange();
  if (effectrange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effectrange_;
    effectrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_effectrange(::std::string* effectrange) {
  if (effectrange_ != &::google::protobuf::internal::kEmptyString) {
    delete effectrange_;
  }
  if (effectrange) {
    set_has_effectrange();
    effectrange_ = effectrange;
  } else {
    clear_has_effectrange();
    effectrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 RoadActiveType = 14;
inline bool building_t_building::has_roadactivetype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void building_t_building::set_has_roadactivetype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void building_t_building::clear_has_roadactivetype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void building_t_building::clear_roadactivetype() {
  roadactivetype_ = 0u;
  clear_has_roadactivetype();
}
inline ::google::protobuf::uint32 building_t_building::roadactivetype() const {
  return roadactivetype_;
}
inline void building_t_building::set_roadactivetype(::google::protobuf::uint32 value) {
  set_has_roadactivetype();
  roadactivetype_ = value;
}

// required uint32 guestReduce = 15;
inline bool building_t_building::has_guestreduce() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void building_t_building::set_has_guestreduce() {
  _has_bits_[0] |= 0x00004000u;
}
inline void building_t_building::clear_has_guestreduce() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void building_t_building::clear_guestreduce() {
  guestreduce_ = 0u;
  clear_has_guestreduce();
}
inline ::google::protobuf::uint32 building_t_building::guestreduce() const {
  return guestreduce_;
}
inline void building_t_building::set_guestreduce(::google::protobuf::uint32 value) {
  set_has_guestreduce();
  guestreduce_ = value;
}

// required double happyIncrease = 16;
inline bool building_t_building::has_happyincrease() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void building_t_building::set_has_happyincrease() {
  _has_bits_[0] |= 0x00008000u;
}
inline void building_t_building::clear_has_happyincrease() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void building_t_building::clear_happyincrease() {
  happyincrease_ = 0;
  clear_has_happyincrease();
}
inline double building_t_building::happyincrease() const {
  return happyincrease_;
}
inline void building_t_building::set_happyincrease(double value) {
  set_has_happyincrease();
  happyincrease_ = value;
}

// required uint32 sellTime = 17;
inline bool building_t_building::has_selltime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void building_t_building::set_has_selltime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void building_t_building::clear_has_selltime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void building_t_building::clear_selltime() {
  selltime_ = 0u;
  clear_has_selltime();
}
inline ::google::protobuf::uint32 building_t_building::selltime() const {
  return selltime_;
}
inline void building_t_building::set_selltime(::google::protobuf::uint32 value) {
  set_has_selltime();
  selltime_ = value;
}

// required uint32 merriness = 18;
inline bool building_t_building::has_merriness() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void building_t_building::set_has_merriness() {
  _has_bits_[0] |= 0x00020000u;
}
inline void building_t_building::clear_has_merriness() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void building_t_building::clear_merriness() {
  merriness_ = 0u;
  clear_has_merriness();
}
inline ::google::protobuf::uint32 building_t_building::merriness() const {
  return merriness_;
}
inline void building_t_building::set_merriness(::google::protobuf::uint32 value) {
  set_has_merriness();
  merriness_ = value;
}

// required uint32 requireGold = 19;
inline bool building_t_building::has_requiregold() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void building_t_building::set_has_requiregold() {
  _has_bits_[0] |= 0x00040000u;
}
inline void building_t_building::clear_has_requiregold() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void building_t_building::clear_requiregold() {
  requiregold_ = 0u;
  clear_has_requiregold();
}
inline ::google::protobuf::uint32 building_t_building::requiregold() const {
  return requiregold_;
}
inline void building_t_building::set_requiregold(::google::protobuf::uint32 value) {
  set_has_requiregold();
  requiregold_ = value;
}

// required string requireItem = 20;
inline bool building_t_building::has_requireitem() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void building_t_building::set_has_requireitem() {
  _has_bits_[0] |= 0x00080000u;
}
inline void building_t_building::clear_has_requireitem() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void building_t_building::clear_requireitem() {
  if (requireitem_ != &::google::protobuf::internal::kEmptyString) {
    requireitem_->clear();
  }
  clear_has_requireitem();
}
inline const ::std::string& building_t_building::requireitem() const {
  return *requireitem_;
}
inline void building_t_building::set_requireitem(const ::std::string& value) {
  set_has_requireitem();
  if (requireitem_ == &::google::protobuf::internal::kEmptyString) {
    requireitem_ = new ::std::string;
  }
  requireitem_->assign(value);
}
inline void building_t_building::set_requireitem(const char* value) {
  set_has_requireitem();
  if (requireitem_ == &::google::protobuf::internal::kEmptyString) {
    requireitem_ = new ::std::string;
  }
  requireitem_->assign(value);
}
inline void building_t_building::set_requireitem(const char* value, size_t size) {
  set_has_requireitem();
  if (requireitem_ == &::google::protobuf::internal::kEmptyString) {
    requireitem_ = new ::std::string;
  }
  requireitem_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_requireitem() {
  set_has_requireitem();
  if (requireitem_ == &::google::protobuf::internal::kEmptyString) {
    requireitem_ = new ::std::string;
  }
  return requireitem_;
}
inline ::std::string* building_t_building::release_requireitem() {
  clear_has_requireitem();
  if (requireitem_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = requireitem_;
    requireitem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_requireitem(::std::string* requireitem) {
  if (requireitem_ != &::google::protobuf::internal::kEmptyString) {
    delete requireitem_;
  }
  if (requireitem) {
    set_has_requireitem();
    requireitem_ = requireitem;
  } else {
    clear_has_requireitem();
    requireitem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 GoldOutput = 21;
inline bool building_t_building::has_goldoutput() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void building_t_building::set_has_goldoutput() {
  _has_bits_[0] |= 0x00100000u;
}
inline void building_t_building::clear_has_goldoutput() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void building_t_building::clear_goldoutput() {
  goldoutput_ = 0u;
  clear_has_goldoutput();
}
inline ::google::protobuf::uint32 building_t_building::goldoutput() const {
  return goldoutput_;
}
inline void building_t_building::set_goldoutput(::google::protobuf::uint32 value) {
  set_has_goldoutput();
  goldoutput_ = value;
}

// required uint32 GoldOutputMax = 22;
inline bool building_t_building::has_goldoutputmax() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void building_t_building::set_has_goldoutputmax() {
  _has_bits_[0] |= 0x00200000u;
}
inline void building_t_building::clear_has_goldoutputmax() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void building_t_building::clear_goldoutputmax() {
  goldoutputmax_ = 0u;
  clear_has_goldoutputmax();
}
inline ::google::protobuf::uint32 building_t_building::goldoutputmax() const {
  return goldoutputmax_;
}
inline void building_t_building::set_goldoutputmax(::google::protobuf::uint32 value) {
  set_has_goldoutputmax();
  goldoutputmax_ = value;
}

// required uint32 makeTime = 23;
inline bool building_t_building::has_maketime() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void building_t_building::set_has_maketime() {
  _has_bits_[0] |= 0x00400000u;
}
inline void building_t_building::clear_has_maketime() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void building_t_building::clear_maketime() {
  maketime_ = 0u;
  clear_has_maketime();
}
inline ::google::protobuf::uint32 building_t_building::maketime() const {
  return maketime_;
}
inline void building_t_building::set_maketime(::google::protobuf::uint32 value) {
  set_has_maketime();
  maketime_ = value;
}

// required uint32 time = 24;
inline bool building_t_building::has_time() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void building_t_building::set_has_time() {
  _has_bits_[0] |= 0x00800000u;
}
inline void building_t_building::clear_has_time() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void building_t_building::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 building_t_building::time() const {
  return time_;
}
inline void building_t_building::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required string effectval = 25;
inline bool building_t_building::has_effectval() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void building_t_building::set_has_effectval() {
  _has_bits_[0] |= 0x01000000u;
}
inline void building_t_building::clear_has_effectval() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void building_t_building::clear_effectval() {
  if (effectval_ != &::google::protobuf::internal::kEmptyString) {
    effectval_->clear();
  }
  clear_has_effectval();
}
inline const ::std::string& building_t_building::effectval() const {
  return *effectval_;
}
inline void building_t_building::set_effectval(const ::std::string& value) {
  set_has_effectval();
  if (effectval_ == &::google::protobuf::internal::kEmptyString) {
    effectval_ = new ::std::string;
  }
  effectval_->assign(value);
}
inline void building_t_building::set_effectval(const char* value) {
  set_has_effectval();
  if (effectval_ == &::google::protobuf::internal::kEmptyString) {
    effectval_ = new ::std::string;
  }
  effectval_->assign(value);
}
inline void building_t_building::set_effectval(const char* value, size_t size) {
  set_has_effectval();
  if (effectval_ == &::google::protobuf::internal::kEmptyString) {
    effectval_ = new ::std::string;
  }
  effectval_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_effectval() {
  set_has_effectval();
  if (effectval_ == &::google::protobuf::internal::kEmptyString) {
    effectval_ = new ::std::string;
  }
  return effectval_;
}
inline ::std::string* building_t_building::release_effectval() {
  clear_has_effectval();
  if (effectval_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effectval_;
    effectval_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_effectval(::std::string* effectval) {
  if (effectval_ != &::google::protobuf::internal::kEmptyString) {
    delete effectval_;
  }
  if (effectval) {
    set_has_effectval();
    effectval_ = effectval;
  } else {
    clear_has_effectval();
    effectval_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string personRequire = 26;
inline bool building_t_building::has_personrequire() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void building_t_building::set_has_personrequire() {
  _has_bits_[0] |= 0x02000000u;
}
inline void building_t_building::clear_has_personrequire() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void building_t_building::clear_personrequire() {
  if (personrequire_ != &::google::protobuf::internal::kEmptyString) {
    personrequire_->clear();
  }
  clear_has_personrequire();
}
inline const ::std::string& building_t_building::personrequire() const {
  return *personrequire_;
}
inline void building_t_building::set_personrequire(const ::std::string& value) {
  set_has_personrequire();
  if (personrequire_ == &::google::protobuf::internal::kEmptyString) {
    personrequire_ = new ::std::string;
  }
  personrequire_->assign(value);
}
inline void building_t_building::set_personrequire(const char* value) {
  set_has_personrequire();
  if (personrequire_ == &::google::protobuf::internal::kEmptyString) {
    personrequire_ = new ::std::string;
  }
  personrequire_->assign(value);
}
inline void building_t_building::set_personrequire(const char* value, size_t size) {
  set_has_personrequire();
  if (personrequire_ == &::google::protobuf::internal::kEmptyString) {
    personrequire_ = new ::std::string;
  }
  personrequire_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_personrequire() {
  set_has_personrequire();
  if (personrequire_ == &::google::protobuf::internal::kEmptyString) {
    personrequire_ = new ::std::string;
  }
  return personrequire_;
}
inline ::std::string* building_t_building::release_personrequire() {
  clear_has_personrequire();
  if (personrequire_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = personrequire_;
    personrequire_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_personrequire(::std::string* personrequire) {
  if (personrequire_ != &::google::protobuf::internal::kEmptyString) {
    delete personrequire_;
  }
  if (personrequire) {
    set_has_personrequire();
    personrequire_ = personrequire;
  } else {
    clear_has_personrequire();
    personrequire_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string iconPic = 27;
inline bool building_t_building::has_iconpic() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void building_t_building::set_has_iconpic() {
  _has_bits_[0] |= 0x04000000u;
}
inline void building_t_building::clear_has_iconpic() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void building_t_building::clear_iconpic() {
  if (iconpic_ != &::google::protobuf::internal::kEmptyString) {
    iconpic_->clear();
  }
  clear_has_iconpic();
}
inline const ::std::string& building_t_building::iconpic() const {
  return *iconpic_;
}
inline void building_t_building::set_iconpic(const ::std::string& value) {
  set_has_iconpic();
  if (iconpic_ == &::google::protobuf::internal::kEmptyString) {
    iconpic_ = new ::std::string;
  }
  iconpic_->assign(value);
}
inline void building_t_building::set_iconpic(const char* value) {
  set_has_iconpic();
  if (iconpic_ == &::google::protobuf::internal::kEmptyString) {
    iconpic_ = new ::std::string;
  }
  iconpic_->assign(value);
}
inline void building_t_building::set_iconpic(const char* value, size_t size) {
  set_has_iconpic();
  if (iconpic_ == &::google::protobuf::internal::kEmptyString) {
    iconpic_ = new ::std::string;
  }
  iconpic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_iconpic() {
  set_has_iconpic();
  if (iconpic_ == &::google::protobuf::internal::kEmptyString) {
    iconpic_ = new ::std::string;
  }
  return iconpic_;
}
inline ::std::string* building_t_building::release_iconpic() {
  clear_has_iconpic();
  if (iconpic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iconpic_;
    iconpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_iconpic(::std::string* iconpic) {
  if (iconpic_ != &::google::protobuf::internal::kEmptyString) {
    delete iconpic_;
  }
  if (iconpic) {
    set_has_iconpic();
    iconpic_ = iconpic;
  } else {
    clear_has_iconpic();
    iconpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string description = 28;
inline bool building_t_building::has_description() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void building_t_building::set_has_description() {
  _has_bits_[0] |= 0x08000000u;
}
inline void building_t_building::clear_has_description() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void building_t_building::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& building_t_building::description() const {
  return *description_;
}
inline void building_t_building::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void building_t_building::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void building_t_building::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* building_t_building::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string usecard = 29;
inline bool building_t_building::has_usecard() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void building_t_building::set_has_usecard() {
  _has_bits_[0] |= 0x10000000u;
}
inline void building_t_building::clear_has_usecard() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void building_t_building::clear_usecard() {
  if (usecard_ != &::google::protobuf::internal::kEmptyString) {
    usecard_->clear();
  }
  clear_has_usecard();
}
inline const ::std::string& building_t_building::usecard() const {
  return *usecard_;
}
inline void building_t_building::set_usecard(const ::std::string& value) {
  set_has_usecard();
  if (usecard_ == &::google::protobuf::internal::kEmptyString) {
    usecard_ = new ::std::string;
  }
  usecard_->assign(value);
}
inline void building_t_building::set_usecard(const char* value) {
  set_has_usecard();
  if (usecard_ == &::google::protobuf::internal::kEmptyString) {
    usecard_ = new ::std::string;
  }
  usecard_->assign(value);
}
inline void building_t_building::set_usecard(const char* value, size_t size) {
  set_has_usecard();
  if (usecard_ == &::google::protobuf::internal::kEmptyString) {
    usecard_ = new ::std::string;
  }
  usecard_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_usecard() {
  set_has_usecard();
  if (usecard_ == &::google::protobuf::internal::kEmptyString) {
    usecard_ = new ::std::string;
  }
  return usecard_;
}
inline ::std::string* building_t_building::release_usecard() {
  clear_has_usecard();
  if (usecard_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = usecard_;
    usecard_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_usecard(::std::string* usecard) {
  if (usecard_ != &::google::protobuf::internal::kEmptyString) {
    delete usecard_;
  }
  if (usecard) {
    set_has_usecard();
    usecard_ = usecard;
  } else {
    clear_has_usecard();
    usecard_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// building

// repeated .pb.building.t_building datas = 1;
inline int building::datas_size() const {
  return datas_.size();
}
inline void building::clear_datas() {
  datas_.Clear();
}
inline const ::pb::building_t_building& building::datas(int index) const {
  return datas_.Get(index);
}
inline ::pb::building_t_building* building::mutable_datas(int index) {
  return datas_.Mutable(index);
}
inline ::pb::building_t_building* building::add_datas() {
  return datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::building_t_building >&
building::datas() const {
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::building_t_building >*
building::mutable_datas() {
  return &datas_;
}

// -------------------------------------------------------------------

// newRoleAttr_t_newRoleAttr

// required uint32 tbxid = 1;
inline bool newRoleAttr_t_newRoleAttr::has_tbxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_tbxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_tbxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void newRoleAttr_t_newRoleAttr::clear_tbxid() {
  tbxid_ = 0u;
  clear_has_tbxid();
}
inline ::google::protobuf::uint32 newRoleAttr_t_newRoleAttr::tbxid() const {
  return tbxid_;
}
inline void newRoleAttr_t_newRoleAttr::set_tbxid(::google::protobuf::uint32 value) {
  set_has_tbxid();
  tbxid_ = value;
}

// required uint32 id = 2;
inline bool newRoleAttr_t_newRoleAttr::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void newRoleAttr_t_newRoleAttr::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 newRoleAttr_t_newRoleAttr::id() const {
  return id_;
}
inline void newRoleAttr_t_newRoleAttr::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 level = 3;
inline bool newRoleAttr_t_newRoleAttr::has_level() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_level() {
  _has_bits_[0] |= 0x00000004u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_level() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void newRoleAttr_t_newRoleAttr::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 newRoleAttr_t_newRoleAttr::level() const {
  return level_;
}
inline void newRoleAttr_t_newRoleAttr::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required string initbuild = 4;
inline bool newRoleAttr_t_newRoleAttr::has_initbuild() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_initbuild() {
  _has_bits_[0] |= 0x00000008u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_initbuild() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void newRoleAttr_t_newRoleAttr::clear_initbuild() {
  if (initbuild_ != &::google::protobuf::internal::kEmptyString) {
    initbuild_->clear();
  }
  clear_has_initbuild();
}
inline const ::std::string& newRoleAttr_t_newRoleAttr::initbuild() const {
  return *initbuild_;
}
inline void newRoleAttr_t_newRoleAttr::set_initbuild(const ::std::string& value) {
  set_has_initbuild();
  if (initbuild_ == &::google::protobuf::internal::kEmptyString) {
    initbuild_ = new ::std::string;
  }
  initbuild_->assign(value);
}
inline void newRoleAttr_t_newRoleAttr::set_initbuild(const char* value) {
  set_has_initbuild();
  if (initbuild_ == &::google::protobuf::internal::kEmptyString) {
    initbuild_ = new ::std::string;
  }
  initbuild_->assign(value);
}
inline void newRoleAttr_t_newRoleAttr::set_initbuild(const char* value, size_t size) {
  set_has_initbuild();
  if (initbuild_ == &::google::protobuf::internal::kEmptyString) {
    initbuild_ = new ::std::string;
  }
  initbuild_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* newRoleAttr_t_newRoleAttr::mutable_initbuild() {
  set_has_initbuild();
  if (initbuild_ == &::google::protobuf::internal::kEmptyString) {
    initbuild_ = new ::std::string;
  }
  return initbuild_;
}
inline ::std::string* newRoleAttr_t_newRoleAttr::release_initbuild() {
  clear_has_initbuild();
  if (initbuild_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = initbuild_;
    initbuild_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void newRoleAttr_t_newRoleAttr::set_allocated_initbuild(::std::string* initbuild) {
  if (initbuild_ != &::google::protobuf::internal::kEmptyString) {
    delete initbuild_;
  }
  if (initbuild) {
    set_has_initbuild();
    initbuild_ = initbuild;
  } else {
    clear_has_initbuild();
    initbuild_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string inititem = 5;
inline bool newRoleAttr_t_newRoleAttr::has_inititem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_inititem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_inititem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void newRoleAttr_t_newRoleAttr::clear_inititem() {
  if (inititem_ != &::google::protobuf::internal::kEmptyString) {
    inititem_->clear();
  }
  clear_has_inititem();
}
inline const ::std::string& newRoleAttr_t_newRoleAttr::inititem() const {
  return *inititem_;
}
inline void newRoleAttr_t_newRoleAttr::set_inititem(const ::std::string& value) {
  set_has_inititem();
  if (inititem_ == &::google::protobuf::internal::kEmptyString) {
    inititem_ = new ::std::string;
  }
  inititem_->assign(value);
}
inline void newRoleAttr_t_newRoleAttr::set_inititem(const char* value) {
  set_has_inititem();
  if (inititem_ == &::google::protobuf::internal::kEmptyString) {
    inititem_ = new ::std::string;
  }
  inititem_->assign(value);
}
inline void newRoleAttr_t_newRoleAttr::set_inititem(const char* value, size_t size) {
  set_has_inititem();
  if (inititem_ == &::google::protobuf::internal::kEmptyString) {
    inititem_ = new ::std::string;
  }
  inititem_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* newRoleAttr_t_newRoleAttr::mutable_inititem() {
  set_has_inititem();
  if (inititem_ == &::google::protobuf::internal::kEmptyString) {
    inititem_ = new ::std::string;
  }
  return inititem_;
}
inline ::std::string* newRoleAttr_t_newRoleAttr::release_inititem() {
  clear_has_inititem();
  if (inititem_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = inititem_;
    inititem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void newRoleAttr_t_newRoleAttr::set_allocated_inititem(::std::string* inititem) {
  if (inititem_ != &::google::protobuf::internal::kEmptyString) {
    delete inititem_;
  }
  if (inititem) {
    set_has_inititem();
    inititem_ = inititem;
  } else {
    clear_has_inititem();
    inititem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// newRoleAttr

// repeated .pb.newRoleAttr.t_newRoleAttr datas = 1;
inline int newRoleAttr::datas_size() const {
  return datas_.size();
}
inline void newRoleAttr::clear_datas() {
  datas_.Clear();
}
inline const ::pb::newRoleAttr_t_newRoleAttr& newRoleAttr::datas(int index) const {
  return datas_.Get(index);
}
inline ::pb::newRoleAttr_t_newRoleAttr* newRoleAttr::mutable_datas(int index) {
  return datas_.Mutable(index);
}
inline ::pb::newRoleAttr_t_newRoleAttr* newRoleAttr::add_datas() {
  return datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::newRoleAttr_t_newRoleAttr >&
newRoleAttr::datas() const {
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::newRoleAttr_t_newRoleAttr >*
newRoleAttr::mutable_datas() {
  return &datas_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_Building_2eproto__INCLUDED
