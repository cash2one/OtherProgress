// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: building.proto

#ifndef PROTOBUF_building_2eproto__INCLUDED
#define PROTOBUF_building_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pb {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_building_2eproto();
void protobuf_AssignDesc_building_2eproto();
void protobuf_ShutdownFile_building_2eproto();

class building;
class building_t_building;
class newRoleAttr;
class newRoleAttr_t_newRoleAttr;

// ===================================================================

class building_t_building : public ::google::protobuf::Message {
 public:
  building_t_building();
  virtual ~building_t_building();

  building_t_building(const building_t_building& from);

  inline building_t_building& operator=(const building_t_building& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const building_t_building& default_instance();

  void Swap(building_t_building* other);

  // implements Message ----------------------------------------------

  building_t_building* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const building_t_building& from);
  void MergeFrom(const building_t_building& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 tbxid = 1;
  inline bool has_tbxid() const;
  inline void clear_tbxid();
  static const int kTbxidFieldNumber = 1;
  inline ::google::protobuf::uint32 tbxid() const;
  inline void set_tbxid(::google::protobuf::uint32 value);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required uint32 dependID = 3;
  inline bool has_dependid() const;
  inline void clear_dependid();
  static const int kDependIDFieldNumber = 3;
  inline ::google::protobuf::uint32 dependid() const;
  inline void set_dependid(::google::protobuf::uint32 value);

  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint32 level = 5;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 5;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 MaxCap = 6;
  inline bool has_maxcap() const;
  inline void clear_maxcap();
  static const int kMaxCapFieldNumber = 6;
  inline ::google::protobuf::uint32 maxcap() const;
  inline void set_maxcap(::google::protobuf::uint32 value);

  // required uint32 GuestProduce = 7;
  inline bool has_guestproduce() const;
  inline void clear_guestproduce();
  static const int kGuestProduceFieldNumber = 7;
  inline ::google::protobuf::uint32 guestproduce() const;
  inline void set_guestproduce(::google::protobuf::uint32 value);

  // required string buildGridInfo = 8;
  inline bool has_buildgridinfo() const;
  inline void clear_buildgridinfo();
  static const int kBuildGridInfoFieldNumber = 8;
  inline const ::std::string& buildgridinfo() const;
  inline void set_buildgridinfo(const ::std::string& value);
  inline void set_buildgridinfo(const char* value);
  inline void set_buildgridinfo(const char* value, size_t size);
  inline ::std::string* mutable_buildgridinfo();
  inline ::std::string* release_buildgridinfo();
  inline void set_allocated_buildgridinfo(::std::string* buildgridinfo);

  // required uint32 infoType = 9;
  inline bool has_infotype() const;
  inline void clear_infotype();
  static const int kInfoTypeFieldNumber = 9;
  inline ::google::protobuf::uint32 infotype() const;
  inline void set_infotype(::google::protobuf::uint32 value);

  // required string buildSpineRes = 10;
  inline bool has_buildspineres() const;
  inline void clear_buildspineres();
  static const int kBuildSpineResFieldNumber = 10;
  inline const ::std::string& buildspineres() const;
  inline void set_buildspineres(const ::std::string& value);
  inline void set_buildspineres(const char* value);
  inline void set_buildspineres(const char* value, size_t size);
  inline ::std::string* mutable_buildspineres();
  inline ::std::string* release_buildspineres();
  inline void set_allocated_buildspineres(::std::string* buildspineres);

  // required string buildKind = 11;
  inline bool has_buildkind() const;
  inline void clear_buildkind();
  static const int kBuildKindFieldNumber = 11;
  inline const ::std::string& buildkind() const;
  inline void set_buildkind(const ::std::string& value);
  inline void set_buildkind(const char* value);
  inline void set_buildkind(const char* value, size_t size);
  inline ::std::string* mutable_buildkind();
  inline ::std::string* release_buildkind();
  inline void set_allocated_buildkind(::std::string* buildkind);

  // required uint32 premiseBuild = 12;
  inline bool has_premisebuild() const;
  inline void clear_premisebuild();
  static const int kPremiseBuildFieldNumber = 12;
  inline ::google::protobuf::uint32 premisebuild() const;
  inline void set_premisebuild(::google::protobuf::uint32 value);

  // required string effectPic = 13;
  inline bool has_effectpic() const;
  inline void clear_effectpic();
  static const int kEffectPicFieldNumber = 13;
  inline const ::std::string& effectpic() const;
  inline void set_effectpic(const ::std::string& value);
  inline void set_effectpic(const char* value);
  inline void set_effectpic(const char* value, size_t size);
  inline ::std::string* mutable_effectpic();
  inline ::std::string* release_effectpic();
  inline void set_allocated_effectpic(::std::string* effectpic);

  // required string effectRange = 14;
  inline bool has_effectrange() const;
  inline void clear_effectrange();
  static const int kEffectRangeFieldNumber = 14;
  inline const ::std::string& effectrange() const;
  inline void set_effectrange(const ::std::string& value);
  inline void set_effectrange(const char* value);
  inline void set_effectrange(const char* value, size_t size);
  inline ::std::string* mutable_effectrange();
  inline ::std::string* release_effectrange();
  inline void set_allocated_effectrange(::std::string* effectrange);

  // required string guestReduce = 15;
  inline bool has_guestreduce() const;
  inline void clear_guestreduce();
  static const int kGuestReduceFieldNumber = 15;
  inline const ::std::string& guestreduce() const;
  inline void set_guestreduce(const ::std::string& value);
  inline void set_guestreduce(const char* value);
  inline void set_guestreduce(const char* value, size_t size);
  inline ::std::string* mutable_guestreduce();
  inline ::std::string* release_guestreduce();
  inline void set_allocated_guestreduce(::std::string* guestreduce);

  // required uint32 happyIncrease = 16;
  inline bool has_happyincrease() const;
  inline void clear_happyincrease();
  static const int kHappyIncreaseFieldNumber = 16;
  inline ::google::protobuf::uint32 happyincrease() const;
  inline void set_happyincrease(::google::protobuf::uint32 value);

  // required string sellTime = 17;
  inline bool has_selltime() const;
  inline void clear_selltime();
  static const int kSellTimeFieldNumber = 17;
  inline const ::std::string& selltime() const;
  inline void set_selltime(const ::std::string& value);
  inline void set_selltime(const char* value);
  inline void set_selltime(const char* value, size_t size);
  inline ::std::string* mutable_selltime();
  inline ::std::string* release_selltime();
  inline void set_allocated_selltime(::std::string* selltime);

  // required uint32 premiseLevel = 18;
  inline bool has_premiselevel() const;
  inline void clear_premiselevel();
  static const int kPremiseLevelFieldNumber = 18;
  inline ::google::protobuf::uint32 premiselevel() const;
  inline void set_premiselevel(::google::protobuf::uint32 value);

  // required string premiseBuild2 = 19;
  inline bool has_premisebuild2() const;
  inline void clear_premisebuild2();
  static const int kPremiseBuild2FieldNumber = 19;
  inline const ::std::string& premisebuild2() const;
  inline void set_premisebuild2(const ::std::string& value);
  inline void set_premisebuild2(const char* value);
  inline void set_premisebuild2(const char* value, size_t size);
  inline ::std::string* mutable_premisebuild2();
  inline ::std::string* release_premisebuild2();
  inline void set_allocated_premisebuild2(::std::string* premisebuild2);

  // required uint32 merriness = 20;
  inline bool has_merriness() const;
  inline void clear_merriness();
  static const int kMerrinessFieldNumber = 20;
  inline ::google::protobuf::uint32 merriness() const;
  inline void set_merriness(::google::protobuf::uint32 value);

  // required uint32 requireGold = 21;
  inline bool has_requiregold() const;
  inline void clear_requiregold();
  static const int kRequireGoldFieldNumber = 21;
  inline ::google::protobuf::uint32 requiregold() const;
  inline void set_requiregold(::google::protobuf::uint32 value);

  // required uint32 requireItem = 22;
  inline bool has_requireitem() const;
  inline void clear_requireitem();
  static const int kRequireItemFieldNumber = 22;
  inline ::google::protobuf::uint32 requireitem() const;
  inline void set_requireitem(::google::protobuf::uint32 value);

  // required uint32 require = 23;
  inline bool has_require() const;
  inline void clear_require();
  static const int kRequireFieldNumber = 23;
  inline ::google::protobuf::uint32 require() const;
  inline void set_require(::google::protobuf::uint32 value);

  // required uint32 requireItem2 = 24;
  inline bool has_requireitem2() const;
  inline void clear_requireitem2();
  static const int kRequireItem2FieldNumber = 24;
  inline ::google::protobuf::uint32 requireitem2() const;
  inline void set_requireitem2(::google::protobuf::uint32 value);

  // required uint32 require2 = 25;
  inline bool has_require2() const;
  inline void clear_require2();
  static const int kRequire2FieldNumber = 25;
  inline ::google::protobuf::uint32 require2() const;
  inline void set_require2(::google::protobuf::uint32 value);

  // required uint32 requireItem3 = 26;
  inline bool has_requireitem3() const;
  inline void clear_requireitem3();
  static const int kRequireItem3FieldNumber = 26;
  inline ::google::protobuf::uint32 requireitem3() const;
  inline void set_requireitem3(::google::protobuf::uint32 value);

  // required uint32 require3 = 27;
  inline bool has_require3() const;
  inline void clear_require3();
  static const int kRequire3FieldNumber = 27;
  inline ::google::protobuf::uint32 require3() const;
  inline void set_require3(::google::protobuf::uint32 value);

  // required uint32 requireItem4 = 28;
  inline bool has_requireitem4() const;
  inline void clear_requireitem4();
  static const int kRequireItem4FieldNumber = 28;
  inline ::google::protobuf::uint32 requireitem4() const;
  inline void set_requireitem4(::google::protobuf::uint32 value);

  // required uint32 require4 = 29;
  inline bool has_require4() const;
  inline void clear_require4();
  static const int kRequire4FieldNumber = 29;
  inline ::google::protobuf::uint32 require4() const;
  inline void set_require4(::google::protobuf::uint32 value);

  // required string produceItem = 30;
  inline bool has_produceitem() const;
  inline void clear_produceitem();
  static const int kProduceItemFieldNumber = 30;
  inline const ::std::string& produceitem() const;
  inline void set_produceitem(const ::std::string& value);
  inline void set_produceitem(const char* value);
  inline void set_produceitem(const char* value, size_t size);
  inline ::std::string* mutable_produceitem();
  inline ::std::string* release_produceitem();
  inline void set_allocated_produceitem(::std::string* produceitem);

  // required uint32 produce = 31;
  inline bool has_produce() const;
  inline void clear_produce();
  static const int kProduceFieldNumber = 31;
  inline ::google::protobuf::uint32 produce() const;
  inline void set_produce(::google::protobuf::uint32 value);

  // required uint32 produceItem2 = 32;
  inline bool has_produceitem2() const;
  inline void clear_produceitem2();
  static const int kProduceItem2FieldNumber = 32;
  inline ::google::protobuf::uint32 produceitem2() const;
  inline void set_produceitem2(::google::protobuf::uint32 value);

  // required uint32 produce2 = 33;
  inline bool has_produce2() const;
  inline void clear_produce2();
  static const int kProduce2FieldNumber = 33;
  inline ::google::protobuf::uint32 produce2() const;
  inline void set_produce2(::google::protobuf::uint32 value);

  // required uint32 produceItem3 = 34;
  inline bool has_produceitem3() const;
  inline void clear_produceitem3();
  static const int kProduceItem3FieldNumber = 34;
  inline ::google::protobuf::uint32 produceitem3() const;
  inline void set_produceitem3(::google::protobuf::uint32 value);

  // required uint32 produce3 = 35;
  inline bool has_produce3() const;
  inline void clear_produce3();
  static const int kProduce3FieldNumber = 35;
  inline ::google::protobuf::uint32 produce3() const;
  inline void set_produce3(::google::protobuf::uint32 value);

  // required uint32 time = 36;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 36;
  inline ::google::protobuf::uint32 time() const;
  inline void set_time(::google::protobuf::uint32 value);

  // required string functionDescribe = 37;
  inline bool has_functiondescribe() const;
  inline void clear_functiondescribe();
  static const int kFunctionDescribeFieldNumber = 37;
  inline const ::std::string& functiondescribe() const;
  inline void set_functiondescribe(const ::std::string& value);
  inline void set_functiondescribe(const char* value);
  inline void set_functiondescribe(const char* value, size_t size);
  inline ::std::string* mutable_functiondescribe();
  inline ::std::string* release_functiondescribe();
  inline void set_allocated_functiondescribe(::std::string* functiondescribe);

  // required uint32 functionValues = 38;
  inline bool has_functionvalues() const;
  inline void clear_functionvalues();
  static const int kFunctionValuesFieldNumber = 38;
  inline ::google::protobuf::uint32 functionvalues() const;
  inline void set_functionvalues(::google::protobuf::uint32 value);

  // required string type = 39;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 39;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // required string personRequire = 40;
  inline bool has_personrequire() const;
  inline void clear_personrequire();
  static const int kPersonRequireFieldNumber = 40;
  inline const ::std::string& personrequire() const;
  inline void set_personrequire(const ::std::string& value);
  inline void set_personrequire(const char* value);
  inline void set_personrequire(const char* value, size_t size);
  inline ::std::string* mutable_personrequire();
  inline ::std::string* release_personrequire();
  inline void set_allocated_personrequire(::std::string* personrequire);

  // required string iconPic = 41;
  inline bool has_iconpic() const;
  inline void clear_iconpic();
  static const int kIconPicFieldNumber = 41;
  inline const ::std::string& iconpic() const;
  inline void set_iconpic(const ::std::string& value);
  inline void set_iconpic(const char* value);
  inline void set_iconpic(const char* value, size_t size);
  inline ::std::string* mutable_iconpic();
  inline ::std::string* release_iconpic();
  inline void set_allocated_iconpic(::std::string* iconpic);

  // required string description = 42;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 42;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // @@protoc_insertion_point(class_scope:pb.building.t_building)
 private:
  inline void set_has_tbxid();
  inline void clear_has_tbxid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_dependid();
  inline void clear_has_dependid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_maxcap();
  inline void clear_has_maxcap();
  inline void set_has_guestproduce();
  inline void clear_has_guestproduce();
  inline void set_has_buildgridinfo();
  inline void clear_has_buildgridinfo();
  inline void set_has_infotype();
  inline void clear_has_infotype();
  inline void set_has_buildspineres();
  inline void clear_has_buildspineres();
  inline void set_has_buildkind();
  inline void clear_has_buildkind();
  inline void set_has_premisebuild();
  inline void clear_has_premisebuild();
  inline void set_has_effectpic();
  inline void clear_has_effectpic();
  inline void set_has_effectrange();
  inline void clear_has_effectrange();
  inline void set_has_guestreduce();
  inline void clear_has_guestreduce();
  inline void set_has_happyincrease();
  inline void clear_has_happyincrease();
  inline void set_has_selltime();
  inline void clear_has_selltime();
  inline void set_has_premiselevel();
  inline void clear_has_premiselevel();
  inline void set_has_premisebuild2();
  inline void clear_has_premisebuild2();
  inline void set_has_merriness();
  inline void clear_has_merriness();
  inline void set_has_requiregold();
  inline void clear_has_requiregold();
  inline void set_has_requireitem();
  inline void clear_has_requireitem();
  inline void set_has_require();
  inline void clear_has_require();
  inline void set_has_requireitem2();
  inline void clear_has_requireitem2();
  inline void set_has_require2();
  inline void clear_has_require2();
  inline void set_has_requireitem3();
  inline void clear_has_requireitem3();
  inline void set_has_require3();
  inline void clear_has_require3();
  inline void set_has_requireitem4();
  inline void clear_has_requireitem4();
  inline void set_has_require4();
  inline void clear_has_require4();
  inline void set_has_produceitem();
  inline void clear_has_produceitem();
  inline void set_has_produce();
  inline void clear_has_produce();
  inline void set_has_produceitem2();
  inline void clear_has_produceitem2();
  inline void set_has_produce2();
  inline void clear_has_produce2();
  inline void set_has_produceitem3();
  inline void clear_has_produceitem3();
  inline void set_has_produce3();
  inline void clear_has_produce3();
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_functiondescribe();
  inline void clear_has_functiondescribe();
  inline void set_has_functionvalues();
  inline void clear_has_functionvalues();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_personrequire();
  inline void clear_has_personrequire();
  inline void set_has_iconpic();
  inline void clear_has_iconpic();
  inline void set_has_description();
  inline void clear_has_description();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tbxid_;
  ::google::protobuf::uint32 id_;
  ::std::string* name_;
  ::google::protobuf::uint32 dependid_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 maxcap_;
  ::google::protobuf::uint32 guestproduce_;
  ::std::string* buildgridinfo_;
  ::std::string* buildspineres_;
  ::google::protobuf::uint32 infotype_;
  ::google::protobuf::uint32 premisebuild_;
  ::std::string* buildkind_;
  ::std::string* effectpic_;
  ::std::string* effectrange_;
  ::std::string* guestreduce_;
  ::std::string* selltime_;
  ::google::protobuf::uint32 happyincrease_;
  ::google::protobuf::uint32 premiselevel_;
  ::std::string* premisebuild2_;
  ::google::protobuf::uint32 merriness_;
  ::google::protobuf::uint32 requiregold_;
  ::google::protobuf::uint32 requireitem_;
  ::google::protobuf::uint32 require_;
  ::google::protobuf::uint32 requireitem2_;
  ::google::protobuf::uint32 require2_;
  ::google::protobuf::uint32 requireitem3_;
  ::google::protobuf::uint32 require3_;
  ::google::protobuf::uint32 requireitem4_;
  ::google::protobuf::uint32 require4_;
  ::std::string* produceitem_;
  ::google::protobuf::uint32 produce_;
  ::google::protobuf::uint32 produceitem2_;
  ::google::protobuf::uint32 produce2_;
  ::google::protobuf::uint32 produceitem3_;
  ::google::protobuf::uint32 produce3_;
  ::google::protobuf::uint32 time_;
  ::std::string* functiondescribe_;
  ::std::string* type_;
  ::std::string* personrequire_;
  ::std::string* iconpic_;
  ::std::string* description_;
  ::google::protobuf::uint32 functionvalues_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(42 + 31) / 32];

  friend void  protobuf_AddDesc_building_2eproto();
  friend void protobuf_AssignDesc_building_2eproto();
  friend void protobuf_ShutdownFile_building_2eproto();

  void InitAsDefaultInstance();
  static building_t_building* default_instance_;
};
// -------------------------------------------------------------------

class building : public ::google::protobuf::Message {
 public:
  building();
  virtual ~building();

  building(const building& from);

  inline building& operator=(const building& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const building& default_instance();

  void Swap(building* other);

  // implements Message ----------------------------------------------

  building* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const building& from);
  void MergeFrom(const building& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef building_t_building t_building;

  // accessors -------------------------------------------------------

  // repeated .pb.building.t_building datas = 1;
  inline int datas_size() const;
  inline void clear_datas();
  static const int kDatasFieldNumber = 1;
  inline const ::pb::building_t_building& datas(int index) const;
  inline ::pb::building_t_building* mutable_datas(int index);
  inline ::pb::building_t_building* add_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::building_t_building >&
      datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::building_t_building >*
      mutable_datas();

  // @@protoc_insertion_point(class_scope:pb.building)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::building_t_building > datas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_building_2eproto();
  friend void protobuf_AssignDesc_building_2eproto();
  friend void protobuf_ShutdownFile_building_2eproto();

  void InitAsDefaultInstance();
  static building* default_instance_;
};
// -------------------------------------------------------------------

class newRoleAttr_t_newRoleAttr : public ::google::protobuf::Message {
 public:
  newRoleAttr_t_newRoleAttr();
  virtual ~newRoleAttr_t_newRoleAttr();

  newRoleAttr_t_newRoleAttr(const newRoleAttr_t_newRoleAttr& from);

  inline newRoleAttr_t_newRoleAttr& operator=(const newRoleAttr_t_newRoleAttr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const newRoleAttr_t_newRoleAttr& default_instance();

  void Swap(newRoleAttr_t_newRoleAttr* other);

  // implements Message ----------------------------------------------

  newRoleAttr_t_newRoleAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const newRoleAttr_t_newRoleAttr& from);
  void MergeFrom(const newRoleAttr_t_newRoleAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 tbxid = 1;
  inline bool has_tbxid() const;
  inline void clear_tbxid();
  static const int kTbxidFieldNumber = 1;
  inline ::google::protobuf::uint32 tbxid() const;
  inline void set_tbxid(::google::protobuf::uint32 value);

  // required uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string initBuild = 3;
  inline bool has_initbuild() const;
  inline void clear_initbuild();
  static const int kInitBuildFieldNumber = 3;
  inline const ::std::string& initbuild() const;
  inline void set_initbuild(const ::std::string& value);
  inline void set_initbuild(const char* value);
  inline void set_initbuild(const char* value, size_t size);
  inline ::std::string* mutable_initbuild();
  inline ::std::string* release_initbuild();
  inline void set_allocated_initbuild(::std::string* initbuild);

  // required uint32 gold = 4;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 4;
  inline ::google::protobuf::uint32 gold() const;
  inline void set_gold(::google::protobuf::uint32 value);

  // required uint32 gem = 5;
  inline bool has_gem() const;
  inline void clear_gem();
  static const int kGemFieldNumber = 5;
  inline ::google::protobuf::uint32 gem() const;
  inline void set_gem(::google::protobuf::uint32 value);

  // required uint32 guest = 6;
  inline bool has_guest() const;
  inline void clear_guest();
  static const int kGuestFieldNumber = 6;
  inline ::google::protobuf::uint32 guest() const;
  inline void set_guest(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pb.newRoleAttr.t_newRoleAttr)
 private:
  inline void set_has_tbxid();
  inline void clear_has_tbxid();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_initbuild();
  inline void clear_has_initbuild();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_gem();
  inline void clear_has_gem();
  inline void set_has_guest();
  inline void clear_has_guest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tbxid_;
  ::google::protobuf::uint32 id_;
  ::std::string* initbuild_;
  ::google::protobuf::uint32 gold_;
  ::google::protobuf::uint32 gem_;
  ::google::protobuf::uint32 guest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_building_2eproto();
  friend void protobuf_AssignDesc_building_2eproto();
  friend void protobuf_ShutdownFile_building_2eproto();

  void InitAsDefaultInstance();
  static newRoleAttr_t_newRoleAttr* default_instance_;
};
// -------------------------------------------------------------------

class newRoleAttr : public ::google::protobuf::Message {
 public:
  newRoleAttr();
  virtual ~newRoleAttr();

  newRoleAttr(const newRoleAttr& from);

  inline newRoleAttr& operator=(const newRoleAttr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const newRoleAttr& default_instance();

  void Swap(newRoleAttr* other);

  // implements Message ----------------------------------------------

  newRoleAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const newRoleAttr& from);
  void MergeFrom(const newRoleAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef newRoleAttr_t_newRoleAttr t_newRoleAttr;

  // accessors -------------------------------------------------------

  // repeated .pb.newRoleAttr.t_newRoleAttr datas = 1;
  inline int datas_size() const;
  inline void clear_datas();
  static const int kDatasFieldNumber = 1;
  inline const ::pb::newRoleAttr_t_newRoleAttr& datas(int index) const;
  inline ::pb::newRoleAttr_t_newRoleAttr* mutable_datas(int index);
  inline ::pb::newRoleAttr_t_newRoleAttr* add_datas();
  inline const ::google::protobuf::RepeatedPtrField< ::pb::newRoleAttr_t_newRoleAttr >&
      datas() const;
  inline ::google::protobuf::RepeatedPtrField< ::pb::newRoleAttr_t_newRoleAttr >*
      mutable_datas();

  // @@protoc_insertion_point(class_scope:pb.newRoleAttr)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pb::newRoleAttr_t_newRoleAttr > datas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_building_2eproto();
  friend void protobuf_AssignDesc_building_2eproto();
  friend void protobuf_ShutdownFile_building_2eproto();

  void InitAsDefaultInstance();
  static newRoleAttr* default_instance_;
};
// ===================================================================


// ===================================================================

// building_t_building

// required uint32 tbxid = 1;
inline bool building_t_building::has_tbxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void building_t_building::set_has_tbxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void building_t_building::clear_has_tbxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void building_t_building::clear_tbxid() {
  tbxid_ = 0u;
  clear_has_tbxid();
}
inline ::google::protobuf::uint32 building_t_building::tbxid() const {
  return tbxid_;
}
inline void building_t_building::set_tbxid(::google::protobuf::uint32 value) {
  set_has_tbxid();
  tbxid_ = value;
}

// required uint32 id = 2;
inline bool building_t_building::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void building_t_building::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void building_t_building::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void building_t_building::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 building_t_building::id() const {
  return id_;
}
inline void building_t_building::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required uint32 dependID = 3;
inline bool building_t_building::has_dependid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void building_t_building::set_has_dependid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void building_t_building::clear_has_dependid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void building_t_building::clear_dependid() {
  dependid_ = 0u;
  clear_has_dependid();
}
inline ::google::protobuf::uint32 building_t_building::dependid() const {
  return dependid_;
}
inline void building_t_building::set_dependid(::google::protobuf::uint32 value) {
  set_has_dependid();
  dependid_ = value;
}

// required string name = 4;
inline bool building_t_building::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void building_t_building::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void building_t_building::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void building_t_building::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& building_t_building::name() const {
  return *name_;
}
inline void building_t_building::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void building_t_building::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void building_t_building::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* building_t_building::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 level = 5;
inline bool building_t_building::has_level() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void building_t_building::set_has_level() {
  _has_bits_[0] |= 0x00000010u;
}
inline void building_t_building::clear_has_level() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void building_t_building::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 building_t_building::level() const {
  return level_;
}
inline void building_t_building::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 MaxCap = 6;
inline bool building_t_building::has_maxcap() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void building_t_building::set_has_maxcap() {
  _has_bits_[0] |= 0x00000020u;
}
inline void building_t_building::clear_has_maxcap() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void building_t_building::clear_maxcap() {
  maxcap_ = 0u;
  clear_has_maxcap();
}
inline ::google::protobuf::uint32 building_t_building::maxcap() const {
  return maxcap_;
}
inline void building_t_building::set_maxcap(::google::protobuf::uint32 value) {
  set_has_maxcap();
  maxcap_ = value;
}

// required uint32 GuestProduce = 7;
inline bool building_t_building::has_guestproduce() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void building_t_building::set_has_guestproduce() {
  _has_bits_[0] |= 0x00000040u;
}
inline void building_t_building::clear_has_guestproduce() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void building_t_building::clear_guestproduce() {
  guestproduce_ = 0u;
  clear_has_guestproduce();
}
inline ::google::protobuf::uint32 building_t_building::guestproduce() const {
  return guestproduce_;
}
inline void building_t_building::set_guestproduce(::google::protobuf::uint32 value) {
  set_has_guestproduce();
  guestproduce_ = value;
}

// required string buildGridInfo = 8;
inline bool building_t_building::has_buildgridinfo() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void building_t_building::set_has_buildgridinfo() {
  _has_bits_[0] |= 0x00000080u;
}
inline void building_t_building::clear_has_buildgridinfo() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void building_t_building::clear_buildgridinfo() {
  if (buildgridinfo_ != &::google::protobuf::internal::kEmptyString) {
    buildgridinfo_->clear();
  }
  clear_has_buildgridinfo();
}
inline const ::std::string& building_t_building::buildgridinfo() const {
  return *buildgridinfo_;
}
inline void building_t_building::set_buildgridinfo(const ::std::string& value) {
  set_has_buildgridinfo();
  if (buildgridinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildgridinfo_ = new ::std::string;
  }
  buildgridinfo_->assign(value);
}
inline void building_t_building::set_buildgridinfo(const char* value) {
  set_has_buildgridinfo();
  if (buildgridinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildgridinfo_ = new ::std::string;
  }
  buildgridinfo_->assign(value);
}
inline void building_t_building::set_buildgridinfo(const char* value, size_t size) {
  set_has_buildgridinfo();
  if (buildgridinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildgridinfo_ = new ::std::string;
  }
  buildgridinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_buildgridinfo() {
  set_has_buildgridinfo();
  if (buildgridinfo_ == &::google::protobuf::internal::kEmptyString) {
    buildgridinfo_ = new ::std::string;
  }
  return buildgridinfo_;
}
inline ::std::string* building_t_building::release_buildgridinfo() {
  clear_has_buildgridinfo();
  if (buildgridinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buildgridinfo_;
    buildgridinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_buildgridinfo(::std::string* buildgridinfo) {
  if (buildgridinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete buildgridinfo_;
  }
  if (buildgridinfo) {
    set_has_buildgridinfo();
    buildgridinfo_ = buildgridinfo;
  } else {
    clear_has_buildgridinfo();
    buildgridinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 infoType = 9;
inline bool building_t_building::has_infotype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void building_t_building::set_has_infotype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void building_t_building::clear_has_infotype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void building_t_building::clear_infotype() {
  infotype_ = 0u;
  clear_has_infotype();
}
inline ::google::protobuf::uint32 building_t_building::infotype() const {
  return infotype_;
}
inline void building_t_building::set_infotype(::google::protobuf::uint32 value) {
  set_has_infotype();
  infotype_ = value;
}

// required string buildSpineRes = 10;
inline bool building_t_building::has_buildspineres() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void building_t_building::set_has_buildspineres() {
  _has_bits_[0] |= 0x00000200u;
}
inline void building_t_building::clear_has_buildspineres() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void building_t_building::clear_buildspineres() {
  if (buildspineres_ != &::google::protobuf::internal::kEmptyString) {
    buildspineres_->clear();
  }
  clear_has_buildspineres();
}
inline const ::std::string& building_t_building::buildspineres() const {
  return *buildspineres_;
}
inline void building_t_building::set_buildspineres(const ::std::string& value) {
  set_has_buildspineres();
  if (buildspineres_ == &::google::protobuf::internal::kEmptyString) {
    buildspineres_ = new ::std::string;
  }
  buildspineres_->assign(value);
}
inline void building_t_building::set_buildspineres(const char* value) {
  set_has_buildspineres();
  if (buildspineres_ == &::google::protobuf::internal::kEmptyString) {
    buildspineres_ = new ::std::string;
  }
  buildspineres_->assign(value);
}
inline void building_t_building::set_buildspineres(const char* value, size_t size) {
  set_has_buildspineres();
  if (buildspineres_ == &::google::protobuf::internal::kEmptyString) {
    buildspineres_ = new ::std::string;
  }
  buildspineres_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_buildspineres() {
  set_has_buildspineres();
  if (buildspineres_ == &::google::protobuf::internal::kEmptyString) {
    buildspineres_ = new ::std::string;
  }
  return buildspineres_;
}
inline ::std::string* building_t_building::release_buildspineres() {
  clear_has_buildspineres();
  if (buildspineres_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buildspineres_;
    buildspineres_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_buildspineres(::std::string* buildspineres) {
  if (buildspineres_ != &::google::protobuf::internal::kEmptyString) {
    delete buildspineres_;
  }
  if (buildspineres) {
    set_has_buildspineres();
    buildspineres_ = buildspineres;
  } else {
    clear_has_buildspineres();
    buildspineres_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string buildKind = 11;
inline bool building_t_building::has_buildkind() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void building_t_building::set_has_buildkind() {
  _has_bits_[0] |= 0x00000400u;
}
inline void building_t_building::clear_has_buildkind() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void building_t_building::clear_buildkind() {
  if (buildkind_ != &::google::protobuf::internal::kEmptyString) {
    buildkind_->clear();
  }
  clear_has_buildkind();
}
inline const ::std::string& building_t_building::buildkind() const {
  return *buildkind_;
}
inline void building_t_building::set_buildkind(const ::std::string& value) {
  set_has_buildkind();
  if (buildkind_ == &::google::protobuf::internal::kEmptyString) {
    buildkind_ = new ::std::string;
  }
  buildkind_->assign(value);
}
inline void building_t_building::set_buildkind(const char* value) {
  set_has_buildkind();
  if (buildkind_ == &::google::protobuf::internal::kEmptyString) {
    buildkind_ = new ::std::string;
  }
  buildkind_->assign(value);
}
inline void building_t_building::set_buildkind(const char* value, size_t size) {
  set_has_buildkind();
  if (buildkind_ == &::google::protobuf::internal::kEmptyString) {
    buildkind_ = new ::std::string;
  }
  buildkind_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_buildkind() {
  set_has_buildkind();
  if (buildkind_ == &::google::protobuf::internal::kEmptyString) {
    buildkind_ = new ::std::string;
  }
  return buildkind_;
}
inline ::std::string* building_t_building::release_buildkind() {
  clear_has_buildkind();
  if (buildkind_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = buildkind_;
    buildkind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_buildkind(::std::string* buildkind) {
  if (buildkind_ != &::google::protobuf::internal::kEmptyString) {
    delete buildkind_;
  }
  if (buildkind) {
    set_has_buildkind();
    buildkind_ = buildkind;
  } else {
    clear_has_buildkind();
    buildkind_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 premiseBuild = 12;
inline bool building_t_building::has_premisebuild() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void building_t_building::set_has_premisebuild() {
  _has_bits_[0] |= 0x00000800u;
}
inline void building_t_building::clear_has_premisebuild() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void building_t_building::clear_premisebuild() {
  premisebuild_ = 0u;
  clear_has_premisebuild();
}
inline ::google::protobuf::uint32 building_t_building::premisebuild() const {
  return premisebuild_;
}
inline void building_t_building::set_premisebuild(::google::protobuf::uint32 value) {
  set_has_premisebuild();
  premisebuild_ = value;
}

// required string effectPic = 13;
inline bool building_t_building::has_effectpic() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void building_t_building::set_has_effectpic() {
  _has_bits_[0] |= 0x00001000u;
}
inline void building_t_building::clear_has_effectpic() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void building_t_building::clear_effectpic() {
  if (effectpic_ != &::google::protobuf::internal::kEmptyString) {
    effectpic_->clear();
  }
  clear_has_effectpic();
}
inline const ::std::string& building_t_building::effectpic() const {
  return *effectpic_;
}
inline void building_t_building::set_effectpic(const ::std::string& value) {
  set_has_effectpic();
  if (effectpic_ == &::google::protobuf::internal::kEmptyString) {
    effectpic_ = new ::std::string;
  }
  effectpic_->assign(value);
}
inline void building_t_building::set_effectpic(const char* value) {
  set_has_effectpic();
  if (effectpic_ == &::google::protobuf::internal::kEmptyString) {
    effectpic_ = new ::std::string;
  }
  effectpic_->assign(value);
}
inline void building_t_building::set_effectpic(const char* value, size_t size) {
  set_has_effectpic();
  if (effectpic_ == &::google::protobuf::internal::kEmptyString) {
    effectpic_ = new ::std::string;
  }
  effectpic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_effectpic() {
  set_has_effectpic();
  if (effectpic_ == &::google::protobuf::internal::kEmptyString) {
    effectpic_ = new ::std::string;
  }
  return effectpic_;
}
inline ::std::string* building_t_building::release_effectpic() {
  clear_has_effectpic();
  if (effectpic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effectpic_;
    effectpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_effectpic(::std::string* effectpic) {
  if (effectpic_ != &::google::protobuf::internal::kEmptyString) {
    delete effectpic_;
  }
  if (effectpic) {
    set_has_effectpic();
    effectpic_ = effectpic;
  } else {
    clear_has_effectpic();
    effectpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string effectRange = 14;
inline bool building_t_building::has_effectrange() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void building_t_building::set_has_effectrange() {
  _has_bits_[0] |= 0x00002000u;
}
inline void building_t_building::clear_has_effectrange() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void building_t_building::clear_effectrange() {
  if (effectrange_ != &::google::protobuf::internal::kEmptyString) {
    effectrange_->clear();
  }
  clear_has_effectrange();
}
inline const ::std::string& building_t_building::effectrange() const {
  return *effectrange_;
}
inline void building_t_building::set_effectrange(const ::std::string& value) {
  set_has_effectrange();
  if (effectrange_ == &::google::protobuf::internal::kEmptyString) {
    effectrange_ = new ::std::string;
  }
  effectrange_->assign(value);
}
inline void building_t_building::set_effectrange(const char* value) {
  set_has_effectrange();
  if (effectrange_ == &::google::protobuf::internal::kEmptyString) {
    effectrange_ = new ::std::string;
  }
  effectrange_->assign(value);
}
inline void building_t_building::set_effectrange(const char* value, size_t size) {
  set_has_effectrange();
  if (effectrange_ == &::google::protobuf::internal::kEmptyString) {
    effectrange_ = new ::std::string;
  }
  effectrange_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_effectrange() {
  set_has_effectrange();
  if (effectrange_ == &::google::protobuf::internal::kEmptyString) {
    effectrange_ = new ::std::string;
  }
  return effectrange_;
}
inline ::std::string* building_t_building::release_effectrange() {
  clear_has_effectrange();
  if (effectrange_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = effectrange_;
    effectrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_effectrange(::std::string* effectrange) {
  if (effectrange_ != &::google::protobuf::internal::kEmptyString) {
    delete effectrange_;
  }
  if (effectrange) {
    set_has_effectrange();
    effectrange_ = effectrange;
  } else {
    clear_has_effectrange();
    effectrange_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string guestReduce = 15;
inline bool building_t_building::has_guestreduce() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void building_t_building::set_has_guestreduce() {
  _has_bits_[0] |= 0x00004000u;
}
inline void building_t_building::clear_has_guestreduce() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void building_t_building::clear_guestreduce() {
  if (guestreduce_ != &::google::protobuf::internal::kEmptyString) {
    guestreduce_->clear();
  }
  clear_has_guestreduce();
}
inline const ::std::string& building_t_building::guestreduce() const {
  return *guestreduce_;
}
inline void building_t_building::set_guestreduce(const ::std::string& value) {
  set_has_guestreduce();
  if (guestreduce_ == &::google::protobuf::internal::kEmptyString) {
    guestreduce_ = new ::std::string;
  }
  guestreduce_->assign(value);
}
inline void building_t_building::set_guestreduce(const char* value) {
  set_has_guestreduce();
  if (guestreduce_ == &::google::protobuf::internal::kEmptyString) {
    guestreduce_ = new ::std::string;
  }
  guestreduce_->assign(value);
}
inline void building_t_building::set_guestreduce(const char* value, size_t size) {
  set_has_guestreduce();
  if (guestreduce_ == &::google::protobuf::internal::kEmptyString) {
    guestreduce_ = new ::std::string;
  }
  guestreduce_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_guestreduce() {
  set_has_guestreduce();
  if (guestreduce_ == &::google::protobuf::internal::kEmptyString) {
    guestreduce_ = new ::std::string;
  }
  return guestreduce_;
}
inline ::std::string* building_t_building::release_guestreduce() {
  clear_has_guestreduce();
  if (guestreduce_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = guestreduce_;
    guestreduce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_guestreduce(::std::string* guestreduce) {
  if (guestreduce_ != &::google::protobuf::internal::kEmptyString) {
    delete guestreduce_;
  }
  if (guestreduce) {
    set_has_guestreduce();
    guestreduce_ = guestreduce;
  } else {
    clear_has_guestreduce();
    guestreduce_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 happyIncrease = 16;
inline bool building_t_building::has_happyincrease() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void building_t_building::set_has_happyincrease() {
  _has_bits_[0] |= 0x00008000u;
}
inline void building_t_building::clear_has_happyincrease() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void building_t_building::clear_happyincrease() {
  happyincrease_ = 0u;
  clear_has_happyincrease();
}
inline ::google::protobuf::uint32 building_t_building::happyincrease() const {
  return happyincrease_;
}
inline void building_t_building::set_happyincrease(::google::protobuf::uint32 value) {
  set_has_happyincrease();
  happyincrease_ = value;
}

// required string sellTime = 17;
inline bool building_t_building::has_selltime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void building_t_building::set_has_selltime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void building_t_building::clear_has_selltime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void building_t_building::clear_selltime() {
  if (selltime_ != &::google::protobuf::internal::kEmptyString) {
    selltime_->clear();
  }
  clear_has_selltime();
}
inline const ::std::string& building_t_building::selltime() const {
  return *selltime_;
}
inline void building_t_building::set_selltime(const ::std::string& value) {
  set_has_selltime();
  if (selltime_ == &::google::protobuf::internal::kEmptyString) {
    selltime_ = new ::std::string;
  }
  selltime_->assign(value);
}
inline void building_t_building::set_selltime(const char* value) {
  set_has_selltime();
  if (selltime_ == &::google::protobuf::internal::kEmptyString) {
    selltime_ = new ::std::string;
  }
  selltime_->assign(value);
}
inline void building_t_building::set_selltime(const char* value, size_t size) {
  set_has_selltime();
  if (selltime_ == &::google::protobuf::internal::kEmptyString) {
    selltime_ = new ::std::string;
  }
  selltime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_selltime() {
  set_has_selltime();
  if (selltime_ == &::google::protobuf::internal::kEmptyString) {
    selltime_ = new ::std::string;
  }
  return selltime_;
}
inline ::std::string* building_t_building::release_selltime() {
  clear_has_selltime();
  if (selltime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = selltime_;
    selltime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_selltime(::std::string* selltime) {
  if (selltime_ != &::google::protobuf::internal::kEmptyString) {
    delete selltime_;
  }
  if (selltime) {
    set_has_selltime();
    selltime_ = selltime;
  } else {
    clear_has_selltime();
    selltime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 premiseLevel = 18;
inline bool building_t_building::has_premiselevel() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void building_t_building::set_has_premiselevel() {
  _has_bits_[0] |= 0x00020000u;
}
inline void building_t_building::clear_has_premiselevel() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void building_t_building::clear_premiselevel() {
  premiselevel_ = 0u;
  clear_has_premiselevel();
}
inline ::google::protobuf::uint32 building_t_building::premiselevel() const {
  return premiselevel_;
}
inline void building_t_building::set_premiselevel(::google::protobuf::uint32 value) {
  set_has_premiselevel();
  premiselevel_ = value;
}

// required string premiseBuild2 = 19;
inline bool building_t_building::has_premisebuild2() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void building_t_building::set_has_premisebuild2() {
  _has_bits_[0] |= 0x00040000u;
}
inline void building_t_building::clear_has_premisebuild2() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void building_t_building::clear_premisebuild2() {
  if (premisebuild2_ != &::google::protobuf::internal::kEmptyString) {
    premisebuild2_->clear();
  }
  clear_has_premisebuild2();
}
inline const ::std::string& building_t_building::premisebuild2() const {
  return *premisebuild2_;
}
inline void building_t_building::set_premisebuild2(const ::std::string& value) {
  set_has_premisebuild2();
  if (premisebuild2_ == &::google::protobuf::internal::kEmptyString) {
    premisebuild2_ = new ::std::string;
  }
  premisebuild2_->assign(value);
}
inline void building_t_building::set_premisebuild2(const char* value) {
  set_has_premisebuild2();
  if (premisebuild2_ == &::google::protobuf::internal::kEmptyString) {
    premisebuild2_ = new ::std::string;
  }
  premisebuild2_->assign(value);
}
inline void building_t_building::set_premisebuild2(const char* value, size_t size) {
  set_has_premisebuild2();
  if (premisebuild2_ == &::google::protobuf::internal::kEmptyString) {
    premisebuild2_ = new ::std::string;
  }
  premisebuild2_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_premisebuild2() {
  set_has_premisebuild2();
  if (premisebuild2_ == &::google::protobuf::internal::kEmptyString) {
    premisebuild2_ = new ::std::string;
  }
  return premisebuild2_;
}
inline ::std::string* building_t_building::release_premisebuild2() {
  clear_has_premisebuild2();
  if (premisebuild2_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = premisebuild2_;
    premisebuild2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_premisebuild2(::std::string* premisebuild2) {
  if (premisebuild2_ != &::google::protobuf::internal::kEmptyString) {
    delete premisebuild2_;
  }
  if (premisebuild2) {
    set_has_premisebuild2();
    premisebuild2_ = premisebuild2;
  } else {
    clear_has_premisebuild2();
    premisebuild2_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 merriness = 20;
inline bool building_t_building::has_merriness() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void building_t_building::set_has_merriness() {
  _has_bits_[0] |= 0x00080000u;
}
inline void building_t_building::clear_has_merriness() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void building_t_building::clear_merriness() {
  merriness_ = 0u;
  clear_has_merriness();
}
inline ::google::protobuf::uint32 building_t_building::merriness() const {
  return merriness_;
}
inline void building_t_building::set_merriness(::google::protobuf::uint32 value) {
  set_has_merriness();
  merriness_ = value;
}

// required uint32 requireGold = 21;
inline bool building_t_building::has_requiregold() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void building_t_building::set_has_requiregold() {
  _has_bits_[0] |= 0x00100000u;
}
inline void building_t_building::clear_has_requiregold() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void building_t_building::clear_requiregold() {
  requiregold_ = 0u;
  clear_has_requiregold();
}
inline ::google::protobuf::uint32 building_t_building::requiregold() const {
  return requiregold_;
}
inline void building_t_building::set_requiregold(::google::protobuf::uint32 value) {
  set_has_requiregold();
  requiregold_ = value;
}

// required uint32 requireItem = 22;
inline bool building_t_building::has_requireitem() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void building_t_building::set_has_requireitem() {
  _has_bits_[0] |= 0x00200000u;
}
inline void building_t_building::clear_has_requireitem() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void building_t_building::clear_requireitem() {
  requireitem_ = 0u;
  clear_has_requireitem();
}
inline ::google::protobuf::uint32 building_t_building::requireitem() const {
  return requireitem_;
}
inline void building_t_building::set_requireitem(::google::protobuf::uint32 value) {
  set_has_requireitem();
  requireitem_ = value;
}

// required uint32 require = 23;
inline bool building_t_building::has_require() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void building_t_building::set_has_require() {
  _has_bits_[0] |= 0x00400000u;
}
inline void building_t_building::clear_has_require() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void building_t_building::clear_require() {
  require_ = 0u;
  clear_has_require();
}
inline ::google::protobuf::uint32 building_t_building::require() const {
  return require_;
}
inline void building_t_building::set_require(::google::protobuf::uint32 value) {
  set_has_require();
  require_ = value;
}

// required uint32 requireItem2 = 24;
inline bool building_t_building::has_requireitem2() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void building_t_building::set_has_requireitem2() {
  _has_bits_[0] |= 0x00800000u;
}
inline void building_t_building::clear_has_requireitem2() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void building_t_building::clear_requireitem2() {
  requireitem2_ = 0u;
  clear_has_requireitem2();
}
inline ::google::protobuf::uint32 building_t_building::requireitem2() const {
  return requireitem2_;
}
inline void building_t_building::set_requireitem2(::google::protobuf::uint32 value) {
  set_has_requireitem2();
  requireitem2_ = value;
}

// required uint32 require2 = 25;
inline bool building_t_building::has_require2() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void building_t_building::set_has_require2() {
  _has_bits_[0] |= 0x01000000u;
}
inline void building_t_building::clear_has_require2() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void building_t_building::clear_require2() {
  require2_ = 0u;
  clear_has_require2();
}
inline ::google::protobuf::uint32 building_t_building::require2() const {
  return require2_;
}
inline void building_t_building::set_require2(::google::protobuf::uint32 value) {
  set_has_require2();
  require2_ = value;
}

// required uint32 requireItem3 = 26;
inline bool building_t_building::has_requireitem3() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void building_t_building::set_has_requireitem3() {
  _has_bits_[0] |= 0x02000000u;
}
inline void building_t_building::clear_has_requireitem3() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void building_t_building::clear_requireitem3() {
  requireitem3_ = 0u;
  clear_has_requireitem3();
}
inline ::google::protobuf::uint32 building_t_building::requireitem3() const {
  return requireitem3_;
}
inline void building_t_building::set_requireitem3(::google::protobuf::uint32 value) {
  set_has_requireitem3();
  requireitem3_ = value;
}

// required uint32 require3 = 27;
inline bool building_t_building::has_require3() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void building_t_building::set_has_require3() {
  _has_bits_[0] |= 0x04000000u;
}
inline void building_t_building::clear_has_require3() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void building_t_building::clear_require3() {
  require3_ = 0u;
  clear_has_require3();
}
inline ::google::protobuf::uint32 building_t_building::require3() const {
  return require3_;
}
inline void building_t_building::set_require3(::google::protobuf::uint32 value) {
  set_has_require3();
  require3_ = value;
}

// required uint32 requireItem4 = 28;
inline bool building_t_building::has_requireitem4() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void building_t_building::set_has_requireitem4() {
  _has_bits_[0] |= 0x08000000u;
}
inline void building_t_building::clear_has_requireitem4() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void building_t_building::clear_requireitem4() {
  requireitem4_ = 0u;
  clear_has_requireitem4();
}
inline ::google::protobuf::uint32 building_t_building::requireitem4() const {
  return requireitem4_;
}
inline void building_t_building::set_requireitem4(::google::protobuf::uint32 value) {
  set_has_requireitem4();
  requireitem4_ = value;
}

// required uint32 require4 = 29;
inline bool building_t_building::has_require4() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void building_t_building::set_has_require4() {
  _has_bits_[0] |= 0x10000000u;
}
inline void building_t_building::clear_has_require4() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void building_t_building::clear_require4() {
  require4_ = 0u;
  clear_has_require4();
}
inline ::google::protobuf::uint32 building_t_building::require4() const {
  return require4_;
}
inline void building_t_building::set_require4(::google::protobuf::uint32 value) {
  set_has_require4();
  require4_ = value;
}

// required string produceItem = 30;
inline bool building_t_building::has_produceitem() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void building_t_building::set_has_produceitem() {
  _has_bits_[0] |= 0x20000000u;
}
inline void building_t_building::clear_has_produceitem() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void building_t_building::clear_produceitem() {
  if (produceitem_ != &::google::protobuf::internal::kEmptyString) {
    produceitem_->clear();
  }
  clear_has_produceitem();
}
inline const ::std::string& building_t_building::produceitem() const {
  return *produceitem_;
}
inline void building_t_building::set_produceitem(const ::std::string& value) {
  set_has_produceitem();
  if (produceitem_ == &::google::protobuf::internal::kEmptyString) {
    produceitem_ = new ::std::string;
  }
  produceitem_->assign(value);
}
inline void building_t_building::set_produceitem(const char* value) {
  set_has_produceitem();
  if (produceitem_ == &::google::protobuf::internal::kEmptyString) {
    produceitem_ = new ::std::string;
  }
  produceitem_->assign(value);
}
inline void building_t_building::set_produceitem(const char* value, size_t size) {
  set_has_produceitem();
  if (produceitem_ == &::google::protobuf::internal::kEmptyString) {
    produceitem_ = new ::std::string;
  }
  produceitem_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_produceitem() {
  set_has_produceitem();
  if (produceitem_ == &::google::protobuf::internal::kEmptyString) {
    produceitem_ = new ::std::string;
  }
  return produceitem_;
}
inline ::std::string* building_t_building::release_produceitem() {
  clear_has_produceitem();
  if (produceitem_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = produceitem_;
    produceitem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_produceitem(::std::string* produceitem) {
  if (produceitem_ != &::google::protobuf::internal::kEmptyString) {
    delete produceitem_;
  }
  if (produceitem) {
    set_has_produceitem();
    produceitem_ = produceitem;
  } else {
    clear_has_produceitem();
    produceitem_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 produce = 31;
inline bool building_t_building::has_produce() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void building_t_building::set_has_produce() {
  _has_bits_[0] |= 0x40000000u;
}
inline void building_t_building::clear_has_produce() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void building_t_building::clear_produce() {
  produce_ = 0u;
  clear_has_produce();
}
inline ::google::protobuf::uint32 building_t_building::produce() const {
  return produce_;
}
inline void building_t_building::set_produce(::google::protobuf::uint32 value) {
  set_has_produce();
  produce_ = value;
}

// required uint32 produceItem2 = 32;
inline bool building_t_building::has_produceitem2() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void building_t_building::set_has_produceitem2() {
  _has_bits_[0] |= 0x80000000u;
}
inline void building_t_building::clear_has_produceitem2() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void building_t_building::clear_produceitem2() {
  produceitem2_ = 0u;
  clear_has_produceitem2();
}
inline ::google::protobuf::uint32 building_t_building::produceitem2() const {
  return produceitem2_;
}
inline void building_t_building::set_produceitem2(::google::protobuf::uint32 value) {
  set_has_produceitem2();
  produceitem2_ = value;
}

// required uint32 produce2 = 33;
inline bool building_t_building::has_produce2() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void building_t_building::set_has_produce2() {
  _has_bits_[1] |= 0x00000001u;
}
inline void building_t_building::clear_has_produce2() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void building_t_building::clear_produce2() {
  produce2_ = 0u;
  clear_has_produce2();
}
inline ::google::protobuf::uint32 building_t_building::produce2() const {
  return produce2_;
}
inline void building_t_building::set_produce2(::google::protobuf::uint32 value) {
  set_has_produce2();
  produce2_ = value;
}

// required uint32 produceItem3 = 34;
inline bool building_t_building::has_produceitem3() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void building_t_building::set_has_produceitem3() {
  _has_bits_[1] |= 0x00000002u;
}
inline void building_t_building::clear_has_produceitem3() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void building_t_building::clear_produceitem3() {
  produceitem3_ = 0u;
  clear_has_produceitem3();
}
inline ::google::protobuf::uint32 building_t_building::produceitem3() const {
  return produceitem3_;
}
inline void building_t_building::set_produceitem3(::google::protobuf::uint32 value) {
  set_has_produceitem3();
  produceitem3_ = value;
}

// required uint32 produce3 = 35;
inline bool building_t_building::has_produce3() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void building_t_building::set_has_produce3() {
  _has_bits_[1] |= 0x00000004u;
}
inline void building_t_building::clear_has_produce3() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void building_t_building::clear_produce3() {
  produce3_ = 0u;
  clear_has_produce3();
}
inline ::google::protobuf::uint32 building_t_building::produce3() const {
  return produce3_;
}
inline void building_t_building::set_produce3(::google::protobuf::uint32 value) {
  set_has_produce3();
  produce3_ = value;
}

// required uint32 time = 36;
inline bool building_t_building::has_time() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void building_t_building::set_has_time() {
  _has_bits_[1] |= 0x00000008u;
}
inline void building_t_building::clear_has_time() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void building_t_building::clear_time() {
  time_ = 0u;
  clear_has_time();
}
inline ::google::protobuf::uint32 building_t_building::time() const {
  return time_;
}
inline void building_t_building::set_time(::google::protobuf::uint32 value) {
  set_has_time();
  time_ = value;
}

// required string functionDescribe = 37;
inline bool building_t_building::has_functiondescribe() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void building_t_building::set_has_functiondescribe() {
  _has_bits_[1] |= 0x00000010u;
}
inline void building_t_building::clear_has_functiondescribe() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void building_t_building::clear_functiondescribe() {
  if (functiondescribe_ != &::google::protobuf::internal::kEmptyString) {
    functiondescribe_->clear();
  }
  clear_has_functiondescribe();
}
inline const ::std::string& building_t_building::functiondescribe() const {
  return *functiondescribe_;
}
inline void building_t_building::set_functiondescribe(const ::std::string& value) {
  set_has_functiondescribe();
  if (functiondescribe_ == &::google::protobuf::internal::kEmptyString) {
    functiondescribe_ = new ::std::string;
  }
  functiondescribe_->assign(value);
}
inline void building_t_building::set_functiondescribe(const char* value) {
  set_has_functiondescribe();
  if (functiondescribe_ == &::google::protobuf::internal::kEmptyString) {
    functiondescribe_ = new ::std::string;
  }
  functiondescribe_->assign(value);
}
inline void building_t_building::set_functiondescribe(const char* value, size_t size) {
  set_has_functiondescribe();
  if (functiondescribe_ == &::google::protobuf::internal::kEmptyString) {
    functiondescribe_ = new ::std::string;
  }
  functiondescribe_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_functiondescribe() {
  set_has_functiondescribe();
  if (functiondescribe_ == &::google::protobuf::internal::kEmptyString) {
    functiondescribe_ = new ::std::string;
  }
  return functiondescribe_;
}
inline ::std::string* building_t_building::release_functiondescribe() {
  clear_has_functiondescribe();
  if (functiondescribe_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = functiondescribe_;
    functiondescribe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_functiondescribe(::std::string* functiondescribe) {
  if (functiondescribe_ != &::google::protobuf::internal::kEmptyString) {
    delete functiondescribe_;
  }
  if (functiondescribe) {
    set_has_functiondescribe();
    functiondescribe_ = functiondescribe;
  } else {
    clear_has_functiondescribe();
    functiondescribe_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 functionValues = 38;
inline bool building_t_building::has_functionvalues() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void building_t_building::set_has_functionvalues() {
  _has_bits_[1] |= 0x00000020u;
}
inline void building_t_building::clear_has_functionvalues() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void building_t_building::clear_functionvalues() {
  functionvalues_ = 0u;
  clear_has_functionvalues();
}
inline ::google::protobuf::uint32 building_t_building::functionvalues() const {
  return functionvalues_;
}
inline void building_t_building::set_functionvalues(::google::protobuf::uint32 value) {
  set_has_functionvalues();
  functionvalues_ = value;
}

// required string type = 39;
inline bool building_t_building::has_type() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void building_t_building::set_has_type() {
  _has_bits_[1] |= 0x00000040u;
}
inline void building_t_building::clear_has_type() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void building_t_building::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& building_t_building::type() const {
  return *type_;
}
inline void building_t_building::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void building_t_building::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void building_t_building::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* building_t_building::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string personRequire = 40;
inline bool building_t_building::has_personrequire() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void building_t_building::set_has_personrequire() {
  _has_bits_[1] |= 0x00000080u;
}
inline void building_t_building::clear_has_personrequire() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void building_t_building::clear_personrequire() {
  if (personrequire_ != &::google::protobuf::internal::kEmptyString) {
    personrequire_->clear();
  }
  clear_has_personrequire();
}
inline const ::std::string& building_t_building::personrequire() const {
  return *personrequire_;
}
inline void building_t_building::set_personrequire(const ::std::string& value) {
  set_has_personrequire();
  if (personrequire_ == &::google::protobuf::internal::kEmptyString) {
    personrequire_ = new ::std::string;
  }
  personrequire_->assign(value);
}
inline void building_t_building::set_personrequire(const char* value) {
  set_has_personrequire();
  if (personrequire_ == &::google::protobuf::internal::kEmptyString) {
    personrequire_ = new ::std::string;
  }
  personrequire_->assign(value);
}
inline void building_t_building::set_personrequire(const char* value, size_t size) {
  set_has_personrequire();
  if (personrequire_ == &::google::protobuf::internal::kEmptyString) {
    personrequire_ = new ::std::string;
  }
  personrequire_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_personrequire() {
  set_has_personrequire();
  if (personrequire_ == &::google::protobuf::internal::kEmptyString) {
    personrequire_ = new ::std::string;
  }
  return personrequire_;
}
inline ::std::string* building_t_building::release_personrequire() {
  clear_has_personrequire();
  if (personrequire_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = personrequire_;
    personrequire_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_personrequire(::std::string* personrequire) {
  if (personrequire_ != &::google::protobuf::internal::kEmptyString) {
    delete personrequire_;
  }
  if (personrequire) {
    set_has_personrequire();
    personrequire_ = personrequire;
  } else {
    clear_has_personrequire();
    personrequire_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string iconPic = 41;
inline bool building_t_building::has_iconpic() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void building_t_building::set_has_iconpic() {
  _has_bits_[1] |= 0x00000100u;
}
inline void building_t_building::clear_has_iconpic() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void building_t_building::clear_iconpic() {
  if (iconpic_ != &::google::protobuf::internal::kEmptyString) {
    iconpic_->clear();
  }
  clear_has_iconpic();
}
inline const ::std::string& building_t_building::iconpic() const {
  return *iconpic_;
}
inline void building_t_building::set_iconpic(const ::std::string& value) {
  set_has_iconpic();
  if (iconpic_ == &::google::protobuf::internal::kEmptyString) {
    iconpic_ = new ::std::string;
  }
  iconpic_->assign(value);
}
inline void building_t_building::set_iconpic(const char* value) {
  set_has_iconpic();
  if (iconpic_ == &::google::protobuf::internal::kEmptyString) {
    iconpic_ = new ::std::string;
  }
  iconpic_->assign(value);
}
inline void building_t_building::set_iconpic(const char* value, size_t size) {
  set_has_iconpic();
  if (iconpic_ == &::google::protobuf::internal::kEmptyString) {
    iconpic_ = new ::std::string;
  }
  iconpic_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_iconpic() {
  set_has_iconpic();
  if (iconpic_ == &::google::protobuf::internal::kEmptyString) {
    iconpic_ = new ::std::string;
  }
  return iconpic_;
}
inline ::std::string* building_t_building::release_iconpic() {
  clear_has_iconpic();
  if (iconpic_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iconpic_;
    iconpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_iconpic(::std::string* iconpic) {
  if (iconpic_ != &::google::protobuf::internal::kEmptyString) {
    delete iconpic_;
  }
  if (iconpic) {
    set_has_iconpic();
    iconpic_ = iconpic;
  } else {
    clear_has_iconpic();
    iconpic_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string description = 42;
inline bool building_t_building::has_description() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void building_t_building::set_has_description() {
  _has_bits_[1] |= 0x00000200u;
}
inline void building_t_building::clear_has_description() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void building_t_building::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& building_t_building::description() const {
  return *description_;
}
inline void building_t_building::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void building_t_building::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void building_t_building::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* building_t_building::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* building_t_building::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void building_t_building::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// building

// repeated .pb.building.t_building datas = 1;
inline int building::datas_size() const {
  return datas_.size();
}
inline void building::clear_datas() {
  datas_.Clear();
}
inline const ::pb::building_t_building& building::datas(int index) const {
  return datas_.Get(index);
}
inline ::pb::building_t_building* building::mutable_datas(int index) {
  return datas_.Mutable(index);
}
inline ::pb::building_t_building* building::add_datas() {
  return datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::building_t_building >&
building::datas() const {
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::building_t_building >*
building::mutable_datas() {
  return &datas_;
}

// -------------------------------------------------------------------

// newRoleAttr_t_newRoleAttr

// required uint32 tbxid = 1;
inline bool newRoleAttr_t_newRoleAttr::has_tbxid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_tbxid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_tbxid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void newRoleAttr_t_newRoleAttr::clear_tbxid() {
  tbxid_ = 0u;
  clear_has_tbxid();
}
inline ::google::protobuf::uint32 newRoleAttr_t_newRoleAttr::tbxid() const {
  return tbxid_;
}
inline void newRoleAttr_t_newRoleAttr::set_tbxid(::google::protobuf::uint32 value) {
  set_has_tbxid();
  tbxid_ = value;
}

// required uint32 id = 2;
inline bool newRoleAttr_t_newRoleAttr::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void newRoleAttr_t_newRoleAttr::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 newRoleAttr_t_newRoleAttr::id() const {
  return id_;
}
inline void newRoleAttr_t_newRoleAttr::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// required string initBuild = 3;
inline bool newRoleAttr_t_newRoleAttr::has_initbuild() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_initbuild() {
  _has_bits_[0] |= 0x00000004u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_initbuild() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void newRoleAttr_t_newRoleAttr::clear_initbuild() {
  if (initbuild_ != &::google::protobuf::internal::kEmptyString) {
    initbuild_->clear();
  }
  clear_has_initbuild();
}
inline const ::std::string& newRoleAttr_t_newRoleAttr::initbuild() const {
  return *initbuild_;
}
inline void newRoleAttr_t_newRoleAttr::set_initbuild(const ::std::string& value) {
  set_has_initbuild();
  if (initbuild_ == &::google::protobuf::internal::kEmptyString) {
    initbuild_ = new ::std::string;
  }
  initbuild_->assign(value);
}
inline void newRoleAttr_t_newRoleAttr::set_initbuild(const char* value) {
  set_has_initbuild();
  if (initbuild_ == &::google::protobuf::internal::kEmptyString) {
    initbuild_ = new ::std::string;
  }
  initbuild_->assign(value);
}
inline void newRoleAttr_t_newRoleAttr::set_initbuild(const char* value, size_t size) {
  set_has_initbuild();
  if (initbuild_ == &::google::protobuf::internal::kEmptyString) {
    initbuild_ = new ::std::string;
  }
  initbuild_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* newRoleAttr_t_newRoleAttr::mutable_initbuild() {
  set_has_initbuild();
  if (initbuild_ == &::google::protobuf::internal::kEmptyString) {
    initbuild_ = new ::std::string;
  }
  return initbuild_;
}
inline ::std::string* newRoleAttr_t_newRoleAttr::release_initbuild() {
  clear_has_initbuild();
  if (initbuild_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = initbuild_;
    initbuild_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void newRoleAttr_t_newRoleAttr::set_allocated_initbuild(::std::string* initbuild) {
  if (initbuild_ != &::google::protobuf::internal::kEmptyString) {
    delete initbuild_;
  }
  if (initbuild) {
    set_has_initbuild();
    initbuild_ = initbuild;
  } else {
    clear_has_initbuild();
    initbuild_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 gold = 4;
inline bool newRoleAttr_t_newRoleAttr::has_gold() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_gold() {
  _has_bits_[0] |= 0x00000008u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_gold() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void newRoleAttr_t_newRoleAttr::clear_gold() {
  gold_ = 0u;
  clear_has_gold();
}
inline ::google::protobuf::uint32 newRoleAttr_t_newRoleAttr::gold() const {
  return gold_;
}
inline void newRoleAttr_t_newRoleAttr::set_gold(::google::protobuf::uint32 value) {
  set_has_gold();
  gold_ = value;
}

// required uint32 gem = 5;
inline bool newRoleAttr_t_newRoleAttr::has_gem() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_gem() {
  _has_bits_[0] |= 0x00000010u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_gem() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void newRoleAttr_t_newRoleAttr::clear_gem() {
  gem_ = 0u;
  clear_has_gem();
}
inline ::google::protobuf::uint32 newRoleAttr_t_newRoleAttr::gem() const {
  return gem_;
}
inline void newRoleAttr_t_newRoleAttr::set_gem(::google::protobuf::uint32 value) {
  set_has_gem();
  gem_ = value;
}

// required uint32 guest = 6;
inline bool newRoleAttr_t_newRoleAttr::has_guest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void newRoleAttr_t_newRoleAttr::set_has_guest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void newRoleAttr_t_newRoleAttr::clear_has_guest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void newRoleAttr_t_newRoleAttr::clear_guest() {
  guest_ = 0u;
  clear_has_guest();
}
inline ::google::protobuf::uint32 newRoleAttr_t_newRoleAttr::guest() const {
  return guest_;
}
inline void newRoleAttr_t_newRoleAttr::set_guest(::google::protobuf::uint32 value) {
  set_has_guest();
  guest_ = value;
}

// -------------------------------------------------------------------

// newRoleAttr

// repeated .pb.newRoleAttr.t_newRoleAttr datas = 1;
inline int newRoleAttr::datas_size() const {
  return datas_.size();
}
inline void newRoleAttr::clear_datas() {
  datas_.Clear();
}
inline const ::pb::newRoleAttr_t_newRoleAttr& newRoleAttr::datas(int index) const {
  return datas_.Get(index);
}
inline ::pb::newRoleAttr_t_newRoleAttr* newRoleAttr::mutable_datas(int index) {
  return datas_.Mutable(index);
}
inline ::pb::newRoleAttr_t_newRoleAttr* newRoleAttr::add_datas() {
  return datas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::newRoleAttr_t_newRoleAttr >&
newRoleAttr::datas() const {
  return datas_;
}
inline ::google::protobuf::RepeatedPtrField< ::pb::newRoleAttr_t_newRoleAttr >*
newRoleAttr::mutable_datas() {
  return &datas_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_building_2eproto__INCLUDED
