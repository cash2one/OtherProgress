// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: login.proto

#ifndef PROTOBUF_login_2eproto__INCLUDED
#define PROTOBUF_login_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace HelloKittyMsgData {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_login_2eproto();
void protobuf_AssignDesc_login_2eproto();
void protobuf_ShutdownFile_login_2eproto();

class ClientRequestVersion;
class ClientRequestLogin;
class ClientLoginFailReturn;
class LoginSuccessReturn;
class LoginGateway;
class GameTime;
class UserBaseInfo;
class ReturnUserInfo;
class RequireCreateRole;
class OpReceiveWorldChatCmd;

enum PhoneType {
  Android = 0,
  Iphone = 1
};
bool PhoneType_IsValid(int value);
const PhoneType PhoneType_MIN = Android;
const PhoneType PhoneType_MAX = Iphone;
const int PhoneType_ARRAYSIZE = PhoneType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PhoneType_descriptor();
inline const ::std::string& PhoneType_Name(PhoneType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PhoneType_descriptor(), value);
}
inline bool PhoneType_Parse(
    const ::std::string& name, PhoneType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PhoneType>(
    PhoneType_descriptor(), name, value);
}
enum NetType {
  Tele = 0,
  NetCom = 1
};
bool NetType_IsValid(int value);
const NetType NetType_MIN = Tele;
const NetType NetType_MAX = NetCom;
const int NetType_ARRAYSIZE = NetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* NetType_descriptor();
inline const ::std::string& NetType_Name(NetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    NetType_descriptor(), value);
}
inline bool NetType_Parse(
    const ::std::string& name, NetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NetType>(
    NetType_descriptor(), name, value);
}
enum UserPlateType {
  Tencent = 0,
  Baidu = 1,
  Qihoo = 2,
  Other = 3
};
bool UserPlateType_IsValid(int value);
const UserPlateType UserPlateType_MIN = Tencent;
const UserPlateType UserPlateType_MAX = Other;
const int UserPlateType_ARRAYSIZE = UserPlateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserPlateType_descriptor();
inline const ::std::string& UserPlateType_Name(UserPlateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserPlateType_descriptor(), value);
}
inline bool UserPlateType_Parse(
    const ::std::string& name, UserPlateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserPlateType>(
    UserPlateType_descriptor(), name, value);
}
enum LoginFailReason {
  AccountOdd = 0,
  VersionError = 1,
  NormalMain = 2,
  GatewayNotOpen = 3,
  UserFull = 4,
  SendZoneError = 5,
  TimeOut = 6,
  UuidError = 7,
  NameIllega = 8,
  NameAgain = 9,
  NotRole = 10
};
bool LoginFailReason_IsValid(int value);
const LoginFailReason LoginFailReason_MIN = AccountOdd;
const LoginFailReason LoginFailReason_MAX = NotRole;
const int LoginFailReason_ARRAYSIZE = LoginFailReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginFailReason_descriptor();
inline const ::std::string& LoginFailReason_Name(LoginFailReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginFailReason_descriptor(), value);
}
inline bool LoginFailReason_Parse(
    const ::std::string& name, LoginFailReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginFailReason>(
    LoginFailReason_descriptor(), name, value);
}
enum LoginRetType {
  Normal = 0,
  Kick = 1
};
bool LoginRetType_IsValid(int value);
const LoginRetType LoginRetType_MIN = Normal;
const LoginRetType LoginRetType_MAX = Kick;
const int LoginRetType_ARRAYSIZE = LoginRetType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LoginRetType_descriptor();
inline const ::std::string& LoginRetType_Name(LoginRetType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LoginRetType_descriptor(), value);
}
inline bool LoginRetType_Parse(
    const ::std::string& name, LoginRetType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LoginRetType>(
    LoginRetType_descriptor(), name, value);
}
enum SexType {
  Male = 0,
  Female = 1
};
bool SexType_IsValid(int value);
const SexType SexType_MIN = Male;
const SexType SexType_MAX = Female;
const int SexType_ARRAYSIZE = SexType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SexType_descriptor();
inline const ::std::string& SexType_Name(SexType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SexType_descriptor(), value);
}
inline bool SexType_Parse(
    const ::std::string& name, SexType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SexType>(
    SexType_descriptor(), name, value);
}
enum SwitchType {
  Open = 0,
  Close = 1
};
bool SwitchType_IsValid(int value);
const SwitchType SwitchType_MIN = Open;
const SwitchType SwitchType_MAX = Close;
const int SwitchType_ARRAYSIZE = SwitchType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SwitchType_descriptor();
inline const ::std::string& SwitchType_Name(SwitchType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SwitchType_descriptor(), value);
}
inline bool SwitchType_Parse(
    const ::std::string& name, SwitchType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SwitchType>(
    SwitchType_descriptor(), name, value);
}
// ===================================================================

class ClientRequestVersion : public ::google::protobuf::Message {
 public:
  ClientRequestVersion();
  virtual ~ClientRequestVersion();

  ClientRequestVersion(const ClientRequestVersion& from);

  inline ClientRequestVersion& operator=(const ClientRequestVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequestVersion& default_instance();

  void Swap(ClientRequestVersion* other);

  // implements Message ----------------------------------------------

  ClientRequestVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequestVersion& from);
  void MergeFrom(const ClientRequestVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 clientVersion = 1;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 clientversion() const;
  inline void set_clientversion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ClientRequestVersion)
 private:
  inline void set_has_clientversion();
  inline void clear_has_clientversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 clientversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ClientRequestVersion* default_instance_;
};
// -------------------------------------------------------------------

class ClientRequestLogin : public ::google::protobuf::Message {
 public:
  ClientRequestLogin();
  virtual ~ClientRequestLogin();

  ClientRequestLogin(const ClientRequestLogin& from);

  inline ClientRequestLogin& operator=(const ClientRequestLogin& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientRequestLogin& default_instance();

  void Swap(ClientRequestLogin* other);

  // implements Message ----------------------------------------------

  ClientRequestLogin* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientRequestLogin& from);
  void MergeFrom(const ClientRequestLogin& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HelloKittyMsgData.PhoneType phoneType = 1;
  inline bool has_phonetype() const;
  inline void clear_phonetype();
  static const int kPhoneTypeFieldNumber = 1;
  inline ::HelloKittyMsgData::PhoneType phonetype() const;
  inline void set_phonetype(::HelloKittyMsgData::PhoneType value);

  // required string phoneUuid = 2;
  inline bool has_phoneuuid() const;
  inline void clear_phoneuuid();
  static const int kPhoneUuidFieldNumber = 2;
  inline const ::std::string& phoneuuid() const;
  inline void set_phoneuuid(const ::std::string& value);
  inline void set_phoneuuid(const char* value);
  inline void set_phoneuuid(const char* value, size_t size);
  inline ::std::string* mutable_phoneuuid();
  inline ::std::string* release_phoneuuid();
  inline void set_allocated_phoneuuid(::std::string* phoneuuid);

  // required uint32 gameZone = 3;
  inline bool has_gamezone() const;
  inline void clear_gamezone();
  static const int kGameZoneFieldNumber = 3;
  inline ::google::protobuf::uint32 gamezone() const;
  inline void set_gamezone(::google::protobuf::uint32 value);

  // required string account = 4;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required .HelloKittyMsgData.NetType netType = 5;
  inline bool has_nettype() const;
  inline void clear_nettype();
  static const int kNetTypeFieldNumber = 5;
  inline ::HelloKittyMsgData::NetType nettype() const;
  inline void set_nettype(::HelloKittyMsgData::NetType value);

  // required .HelloKittyMsgData.UserPlateType usertype = 6;
  inline bool has_usertype() const;
  inline void clear_usertype();
  static const int kUsertypeFieldNumber = 6;
  inline ::HelloKittyMsgData::UserPlateType usertype() const;
  inline void set_usertype(::HelloKittyMsgData::UserPlateType value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ClientRequestLogin)
 private:
  inline void set_has_phonetype();
  inline void clear_has_phonetype();
  inline void set_has_phoneuuid();
  inline void clear_has_phoneuuid();
  inline void set_has_gamezone();
  inline void clear_has_gamezone();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_nettype();
  inline void clear_has_nettype();
  inline void set_has_usertype();
  inline void clear_has_usertype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* phoneuuid_;
  int phonetype_;
  ::google::protobuf::uint32 gamezone_;
  ::std::string* account_;
  int nettype_;
  int usertype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ClientRequestLogin* default_instance_;
};
// -------------------------------------------------------------------

class ClientLoginFailReturn : public ::google::protobuf::Message {
 public:
  ClientLoginFailReturn();
  virtual ~ClientLoginFailReturn();

  ClientLoginFailReturn(const ClientLoginFailReturn& from);

  inline ClientLoginFailReturn& operator=(const ClientLoginFailReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClientLoginFailReturn& default_instance();

  void Swap(ClientLoginFailReturn* other);

  // implements Message ----------------------------------------------

  ClientLoginFailReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClientLoginFailReturn& from);
  void MergeFrom(const ClientLoginFailReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HelloKittyMsgData.LoginFailReason failReason = 1;
  inline bool has_failreason() const;
  inline void clear_failreason();
  static const int kFailReasonFieldNumber = 1;
  inline ::HelloKittyMsgData::LoginFailReason failreason() const;
  inline void set_failreason(::HelloKittyMsgData::LoginFailReason value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ClientLoginFailReturn)
 private:
  inline void set_has_failreason();
  inline void clear_has_failreason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int failreason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ClientLoginFailReturn* default_instance_;
};
// -------------------------------------------------------------------

class LoginSuccessReturn : public ::google::protobuf::Message {
 public:
  LoginSuccessReturn();
  virtual ~LoginSuccessReturn();

  LoginSuccessReturn(const LoginSuccessReturn& from);

  inline LoginSuccessReturn& operator=(const LoginSuccessReturn& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginSuccessReturn& default_instance();

  void Swap(LoginSuccessReturn* other);

  // implements Message ----------------------------------------------

  LoginSuccessReturn* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginSuccessReturn& from);
  void MergeFrom(const LoginSuccessReturn& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 loginTempID = 1;
  inline bool has_logintempid() const;
  inline void clear_logintempid();
  static const int kLoginTempIDFieldNumber = 1;
  inline ::google::protobuf::uint32 logintempid() const;
  inline void set_logintempid(::google::protobuf::uint32 value);

  // required string gatewayIP = 2;
  inline bool has_gatewayip() const;
  inline void clear_gatewayip();
  static const int kGatewayIPFieldNumber = 2;
  inline const ::std::string& gatewayip() const;
  inline void set_gatewayip(const ::std::string& value);
  inline void set_gatewayip(const char* value);
  inline void set_gatewayip(const char* value, size_t size);
  inline ::std::string* mutable_gatewayip();
  inline ::std::string* release_gatewayip();
  inline void set_allocated_gatewayip(::std::string* gatewayip);

  // required uint32 gatewayPort = 3;
  inline bool has_gatewayport() const;
  inline void clear_gatewayport();
  static const int kGatewayPortFieldNumber = 3;
  inline ::google::protobuf::uint32 gatewayport() const;
  inline void set_gatewayport(::google::protobuf::uint32 value);

  // repeated uint32 keyArr = 4;
  inline int keyarr_size() const;
  inline void clear_keyarr();
  static const int kKeyArrFieldNumber = 4;
  inline ::google::protobuf::uint32 keyarr(int index) const;
  inline void set_keyarr(int index, ::google::protobuf::uint32 value);
  inline void add_keyarr(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      keyarr() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_keyarr();

  // required .HelloKittyMsgData.LoginRetType loginRet = 5;
  inline bool has_loginret() const;
  inline void clear_loginret();
  static const int kLoginRetFieldNumber = 5;
  inline ::HelloKittyMsgData::LoginRetType loginret() const;
  inline void set_loginret(::HelloKittyMsgData::LoginRetType value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.LoginSuccessReturn)
 private:
  inline void set_has_logintempid();
  inline void clear_has_logintempid();
  inline void set_has_gatewayip();
  inline void clear_has_gatewayip();
  inline void set_has_gatewayport();
  inline void clear_has_gatewayport();
  inline void set_has_loginret();
  inline void clear_has_loginret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gatewayip_;
  ::google::protobuf::uint32 logintempid_;
  ::google::protobuf::uint32 gatewayport_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > keyarr_;
  int loginret_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static LoginSuccessReturn* default_instance_;
};
// -------------------------------------------------------------------

class LoginGateway : public ::google::protobuf::Message {
 public:
  LoginGateway();
  virtual ~LoginGateway();

  LoginGateway(const LoginGateway& from);

  inline LoginGateway& operator=(const LoginGateway& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginGateway& default_instance();

  void Swap(LoginGateway* other);

  // implements Message ----------------------------------------------

  LoginGateway* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginGateway& from);
  void MergeFrom(const LoginGateway& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string account = 1;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 1;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // required .HelloKittyMsgData.UserPlateType usertype = 2;
  inline bool has_usertype() const;
  inline void clear_usertype();
  static const int kUsertypeFieldNumber = 2;
  inline ::HelloKittyMsgData::UserPlateType usertype() const;
  inline void set_usertype(::HelloKittyMsgData::UserPlateType value);

  // required .HelloKittyMsgData.PhoneType phoneType = 3;
  inline bool has_phonetype() const;
  inline void clear_phonetype();
  static const int kPhoneTypeFieldNumber = 3;
  inline ::HelloKittyMsgData::PhoneType phonetype() const;
  inline void set_phonetype(::HelloKittyMsgData::PhoneType value);

  // required string phoneUuid = 4;
  inline bool has_phoneuuid() const;
  inline void clear_phoneuuid();
  static const int kPhoneUuidFieldNumber = 4;
  inline const ::std::string& phoneuuid() const;
  inline void set_phoneuuid(const ::std::string& value);
  inline void set_phoneuuid(const char* value);
  inline void set_phoneuuid(const char* value, size_t size);
  inline ::std::string* mutable_phoneuuid();
  inline ::std::string* release_phoneuuid();
  inline void set_allocated_phoneuuid(::std::string* phoneuuid);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.LoginGateway)
 private:
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_usertype();
  inline void clear_has_usertype();
  inline void set_has_phonetype();
  inline void clear_has_phonetype();
  inline void set_has_phoneuuid();
  inline void clear_has_phoneuuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* account_;
  int usertype_;
  int phonetype_;
  ::std::string* phoneuuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static LoginGateway* default_instance_;
};
// -------------------------------------------------------------------

class GameTime : public ::google::protobuf::Message {
 public:
  GameTime();
  virtual ~GameTime();

  GameTime(const GameTime& from);

  inline GameTime& operator=(const GameTime& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameTime& default_instance();

  void Swap(GameTime* other);

  // implements Message ----------------------------------------------

  GameTime* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameTime& from);
  void MergeFrom(const GameTime& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gameTime = 1;
  inline bool has_gametime() const;
  inline void clear_gametime();
  static const int kGameTimeFieldNumber = 1;
  inline ::google::protobuf::uint64 gametime() const;
  inline void set_gametime(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.GameTime)
 private:
  inline void set_has_gametime();
  inline void clear_has_gametime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gametime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static GameTime* default_instance_;
};
// -------------------------------------------------------------------

class UserBaseInfo : public ::google::protobuf::Message {
 public:
  UserBaseInfo();
  virtual ~UserBaseInfo();

  UserBaseInfo(const UserBaseInfo& from);

  inline UserBaseInfo& operator=(const UserBaseInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserBaseInfo& default_instance();

  void Swap(UserBaseInfo* other);

  // implements Message ----------------------------------------------

  UserBaseInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserBaseInfo& from);
  void MergeFrom(const UserBaseInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 charId = 1;
  inline bool has_charid() const;
  inline void clear_charid();
  static const int kCharIdFieldNumber = 1;
  inline ::google::protobuf::uint64 charid() const;
  inline void set_charid(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .HelloKittyMsgData.SexType sex = 3;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline ::HelloKittyMsgData::SexType sex() const;
  inline void set_sex(::HelloKittyMsgData::SexType value);

  // required uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint64 exp = 5;
  inline bool has_exp() const;
  inline void clear_exp();
  static const int kExpFieldNumber = 5;
  inline ::google::protobuf::uint64 exp() const;
  inline void set_exp(::google::protobuf::uint64 value);

  // required uint64 gold = 6;
  inline bool has_gold() const;
  inline void clear_gold();
  static const int kGoldFieldNumber = 6;
  inline ::google::protobuf::uint64 gold() const;
  inline void set_gold(::google::protobuf::uint64 value);

  // required uint64 gem = 7;
  inline bool has_gem() const;
  inline void clear_gem();
  static const int kGemFieldNumber = 7;
  inline ::google::protobuf::uint64 gem() const;
  inline void set_gem(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.UserBaseInfo)
 private:
  inline void set_has_charid();
  inline void clear_has_charid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_exp();
  inline void clear_has_exp();
  inline void set_has_gold();
  inline void clear_has_gold();
  inline void set_has_gem();
  inline void clear_has_gem();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 charid_;
  ::std::string* name_;
  int sex_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint64 exp_;
  ::google::protobuf::uint64 gold_;
  ::google::protobuf::uint64 gem_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static UserBaseInfo* default_instance_;
};
// -------------------------------------------------------------------

class ReturnUserInfo : public ::google::protobuf::Message {
 public:
  ReturnUserInfo();
  virtual ~ReturnUserInfo();

  ReturnUserInfo(const ReturnUserInfo& from);

  inline ReturnUserInfo& operator=(const ReturnUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReturnUserInfo& default_instance();

  void Swap(ReturnUserInfo* other);

  // implements Message ----------------------------------------------

  ReturnUserInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReturnUserInfo& from);
  void MergeFrom(const ReturnUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool hasUser = 1;
  inline bool has_hasuser() const;
  inline void clear_hasuser();
  static const int kHasUserFieldNumber = 1;
  inline bool hasuser() const;
  inline void set_hasuser(bool value);

  // required .HelloKittyMsgData.UserBaseInfo userBase = 2;
  inline bool has_userbase() const;
  inline void clear_userbase();
  static const int kUserBaseFieldNumber = 2;
  inline const ::HelloKittyMsgData::UserBaseInfo& userbase() const;
  inline ::HelloKittyMsgData::UserBaseInfo* mutable_userbase();
  inline ::HelloKittyMsgData::UserBaseInfo* release_userbase();
  inline void set_allocated_userbase(::HelloKittyMsgData::UserBaseInfo* userbase);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.ReturnUserInfo)
 private:
  inline void set_has_hasuser();
  inline void clear_has_hasuser();
  inline void set_has_userbase();
  inline void clear_has_userbase();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::HelloKittyMsgData::UserBaseInfo* userbase_;
  bool hasuser_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static ReturnUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class RequireCreateRole : public ::google::protobuf::Message {
 public:
  RequireCreateRole();
  virtual ~RequireCreateRole();

  RequireCreateRole(const RequireCreateRole& from);

  inline RequireCreateRole& operator=(const RequireCreateRole& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RequireCreateRole& default_instance();

  void Swap(RequireCreateRole* other);

  // implements Message ----------------------------------------------

  RequireCreateRole* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RequireCreateRole& from);
  void MergeFrom(const RequireCreateRole& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required .HelloKittyMsgData.SexType sex = 2;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 2;
  inline ::HelloKittyMsgData::SexType sex() const;
  inline void set_sex(::HelloKittyMsgData::SexType value);

  // required uint32 heroId = 3;
  inline bool has_heroid() const;
  inline void clear_heroid();
  static const int kHeroIdFieldNumber = 3;
  inline ::google::protobuf::uint32 heroid() const;
  inline void set_heroid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.RequireCreateRole)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_heroid();
  inline void clear_has_heroid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  int sex_;
  ::google::protobuf::uint32 heroid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static RequireCreateRole* default_instance_;
};
// -------------------------------------------------------------------

class OpReceiveWorldChatCmd : public ::google::protobuf::Message {
 public:
  OpReceiveWorldChatCmd();
  virtual ~OpReceiveWorldChatCmd();

  OpReceiveWorldChatCmd(const OpReceiveWorldChatCmd& from);

  inline OpReceiveWorldChatCmd& operator=(const OpReceiveWorldChatCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OpReceiveWorldChatCmd& default_instance();

  void Swap(OpReceiveWorldChatCmd* other);

  // implements Message ----------------------------------------------

  OpReceiveWorldChatCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OpReceiveWorldChatCmd& from);
  void MergeFrom(const OpReceiveWorldChatCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .HelloKittyMsgData.SwitchType switchFlg = 1;
  inline bool has_switchflg() const;
  inline void clear_switchflg();
  static const int kSwitchFlgFieldNumber = 1;
  inline ::HelloKittyMsgData::SwitchType switchflg() const;
  inline void set_switchflg(::HelloKittyMsgData::SwitchType value);

  // @@protoc_insertion_point(class_scope:HelloKittyMsgData.OpReceiveWorldChatCmd)
 private:
  inline void set_has_switchflg();
  inline void clear_has_switchflg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int switchflg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_login_2eproto();
  friend void protobuf_AssignDesc_login_2eproto();
  friend void protobuf_ShutdownFile_login_2eproto();

  void InitAsDefaultInstance();
  static OpReceiveWorldChatCmd* default_instance_;
};
// ===================================================================


// ===================================================================

// ClientRequestVersion

// required uint32 clientVersion = 1;
inline bool ClientRequestVersion::has_clientversion() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequestVersion::set_has_clientversion() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequestVersion::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequestVersion::clear_clientversion() {
  clientversion_ = 0u;
  clear_has_clientversion();
}
inline ::google::protobuf::uint32 ClientRequestVersion::clientversion() const {
  return clientversion_;
}
inline void ClientRequestVersion::set_clientversion(::google::protobuf::uint32 value) {
  set_has_clientversion();
  clientversion_ = value;
}

// -------------------------------------------------------------------

// ClientRequestLogin

// required .HelloKittyMsgData.PhoneType phoneType = 1;
inline bool ClientRequestLogin::has_phonetype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientRequestLogin::set_has_phonetype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientRequestLogin::clear_has_phonetype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientRequestLogin::clear_phonetype() {
  phonetype_ = 0;
  clear_has_phonetype();
}
inline ::HelloKittyMsgData::PhoneType ClientRequestLogin::phonetype() const {
  return static_cast< ::HelloKittyMsgData::PhoneType >(phonetype_);
}
inline void ClientRequestLogin::set_phonetype(::HelloKittyMsgData::PhoneType value) {
  assert(::HelloKittyMsgData::PhoneType_IsValid(value));
  set_has_phonetype();
  phonetype_ = value;
}

// required string phoneUuid = 2;
inline bool ClientRequestLogin::has_phoneuuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ClientRequestLogin::set_has_phoneuuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ClientRequestLogin::clear_has_phoneuuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ClientRequestLogin::clear_phoneuuid() {
  if (phoneuuid_ != &::google::protobuf::internal::kEmptyString) {
    phoneuuid_->clear();
  }
  clear_has_phoneuuid();
}
inline const ::std::string& ClientRequestLogin::phoneuuid() const {
  return *phoneuuid_;
}
inline void ClientRequestLogin::set_phoneuuid(const ::std::string& value) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(value);
}
inline void ClientRequestLogin::set_phoneuuid(const char* value) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(value);
}
inline void ClientRequestLogin::set_phoneuuid(const char* value, size_t size) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientRequestLogin::mutable_phoneuuid() {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  return phoneuuid_;
}
inline ::std::string* ClientRequestLogin::release_phoneuuid() {
  clear_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phoneuuid_;
    phoneuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientRequestLogin::set_allocated_phoneuuid(::std::string* phoneuuid) {
  if (phoneuuid_ != &::google::protobuf::internal::kEmptyString) {
    delete phoneuuid_;
  }
  if (phoneuuid) {
    set_has_phoneuuid();
    phoneuuid_ = phoneuuid;
  } else {
    clear_has_phoneuuid();
    phoneuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 gameZone = 3;
inline bool ClientRequestLogin::has_gamezone() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ClientRequestLogin::set_has_gamezone() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ClientRequestLogin::clear_has_gamezone() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ClientRequestLogin::clear_gamezone() {
  gamezone_ = 0u;
  clear_has_gamezone();
}
inline ::google::protobuf::uint32 ClientRequestLogin::gamezone() const {
  return gamezone_;
}
inline void ClientRequestLogin::set_gamezone(::google::protobuf::uint32 value) {
  set_has_gamezone();
  gamezone_ = value;
}

// required string account = 4;
inline bool ClientRequestLogin::has_account() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ClientRequestLogin::set_has_account() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ClientRequestLogin::clear_has_account() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ClientRequestLogin::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& ClientRequestLogin::account() const {
  return *account_;
}
inline void ClientRequestLogin::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientRequestLogin::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void ClientRequestLogin::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ClientRequestLogin::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* ClientRequestLogin::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ClientRequestLogin::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .HelloKittyMsgData.NetType netType = 5;
inline bool ClientRequestLogin::has_nettype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ClientRequestLogin::set_has_nettype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ClientRequestLogin::clear_has_nettype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ClientRequestLogin::clear_nettype() {
  nettype_ = 0;
  clear_has_nettype();
}
inline ::HelloKittyMsgData::NetType ClientRequestLogin::nettype() const {
  return static_cast< ::HelloKittyMsgData::NetType >(nettype_);
}
inline void ClientRequestLogin::set_nettype(::HelloKittyMsgData::NetType value) {
  assert(::HelloKittyMsgData::NetType_IsValid(value));
  set_has_nettype();
  nettype_ = value;
}

// required .HelloKittyMsgData.UserPlateType usertype = 6;
inline bool ClientRequestLogin::has_usertype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ClientRequestLogin::set_has_usertype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ClientRequestLogin::clear_has_usertype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ClientRequestLogin::clear_usertype() {
  usertype_ = 0;
  clear_has_usertype();
}
inline ::HelloKittyMsgData::UserPlateType ClientRequestLogin::usertype() const {
  return static_cast< ::HelloKittyMsgData::UserPlateType >(usertype_);
}
inline void ClientRequestLogin::set_usertype(::HelloKittyMsgData::UserPlateType value) {
  assert(::HelloKittyMsgData::UserPlateType_IsValid(value));
  set_has_usertype();
  usertype_ = value;
}

// -------------------------------------------------------------------

// ClientLoginFailReturn

// required .HelloKittyMsgData.LoginFailReason failReason = 1;
inline bool ClientLoginFailReturn::has_failreason() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ClientLoginFailReturn::set_has_failreason() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ClientLoginFailReturn::clear_has_failreason() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ClientLoginFailReturn::clear_failreason() {
  failreason_ = 0;
  clear_has_failreason();
}
inline ::HelloKittyMsgData::LoginFailReason ClientLoginFailReturn::failreason() const {
  return static_cast< ::HelloKittyMsgData::LoginFailReason >(failreason_);
}
inline void ClientLoginFailReturn::set_failreason(::HelloKittyMsgData::LoginFailReason value) {
  assert(::HelloKittyMsgData::LoginFailReason_IsValid(value));
  set_has_failreason();
  failreason_ = value;
}

// -------------------------------------------------------------------

// LoginSuccessReturn

// required uint32 loginTempID = 1;
inline bool LoginSuccessReturn::has_logintempid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginSuccessReturn::set_has_logintempid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginSuccessReturn::clear_has_logintempid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginSuccessReturn::clear_logintempid() {
  logintempid_ = 0u;
  clear_has_logintempid();
}
inline ::google::protobuf::uint32 LoginSuccessReturn::logintempid() const {
  return logintempid_;
}
inline void LoginSuccessReturn::set_logintempid(::google::protobuf::uint32 value) {
  set_has_logintempid();
  logintempid_ = value;
}

// required string gatewayIP = 2;
inline bool LoginSuccessReturn::has_gatewayip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginSuccessReturn::set_has_gatewayip() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginSuccessReturn::clear_has_gatewayip() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginSuccessReturn::clear_gatewayip() {
  if (gatewayip_ != &::google::protobuf::internal::kEmptyString) {
    gatewayip_->clear();
  }
  clear_has_gatewayip();
}
inline const ::std::string& LoginSuccessReturn::gatewayip() const {
  return *gatewayip_;
}
inline void LoginSuccessReturn::set_gatewayip(const ::std::string& value) {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  gatewayip_->assign(value);
}
inline void LoginSuccessReturn::set_gatewayip(const char* value) {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  gatewayip_->assign(value);
}
inline void LoginSuccessReturn::set_gatewayip(const char* value, size_t size) {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  gatewayip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginSuccessReturn::mutable_gatewayip() {
  set_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    gatewayip_ = new ::std::string;
  }
  return gatewayip_;
}
inline ::std::string* LoginSuccessReturn::release_gatewayip() {
  clear_has_gatewayip();
  if (gatewayip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gatewayip_;
    gatewayip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginSuccessReturn::set_allocated_gatewayip(::std::string* gatewayip) {
  if (gatewayip_ != &::google::protobuf::internal::kEmptyString) {
    delete gatewayip_;
  }
  if (gatewayip) {
    set_has_gatewayip();
    gatewayip_ = gatewayip;
  } else {
    clear_has_gatewayip();
    gatewayip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 gatewayPort = 3;
inline bool LoginSuccessReturn::has_gatewayport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginSuccessReturn::set_has_gatewayport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginSuccessReturn::clear_has_gatewayport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginSuccessReturn::clear_gatewayport() {
  gatewayport_ = 0u;
  clear_has_gatewayport();
}
inline ::google::protobuf::uint32 LoginSuccessReturn::gatewayport() const {
  return gatewayport_;
}
inline void LoginSuccessReturn::set_gatewayport(::google::protobuf::uint32 value) {
  set_has_gatewayport();
  gatewayport_ = value;
}

// repeated uint32 keyArr = 4;
inline int LoginSuccessReturn::keyarr_size() const {
  return keyarr_.size();
}
inline void LoginSuccessReturn::clear_keyarr() {
  keyarr_.Clear();
}
inline ::google::protobuf::uint32 LoginSuccessReturn::keyarr(int index) const {
  return keyarr_.Get(index);
}
inline void LoginSuccessReturn::set_keyarr(int index, ::google::protobuf::uint32 value) {
  keyarr_.Set(index, value);
}
inline void LoginSuccessReturn::add_keyarr(::google::protobuf::uint32 value) {
  keyarr_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
LoginSuccessReturn::keyarr() const {
  return keyarr_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
LoginSuccessReturn::mutable_keyarr() {
  return &keyarr_;
}

// required .HelloKittyMsgData.LoginRetType loginRet = 5;
inline bool LoginSuccessReturn::has_loginret() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoginSuccessReturn::set_has_loginret() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoginSuccessReturn::clear_has_loginret() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoginSuccessReturn::clear_loginret() {
  loginret_ = 0;
  clear_has_loginret();
}
inline ::HelloKittyMsgData::LoginRetType LoginSuccessReturn::loginret() const {
  return static_cast< ::HelloKittyMsgData::LoginRetType >(loginret_);
}
inline void LoginSuccessReturn::set_loginret(::HelloKittyMsgData::LoginRetType value) {
  assert(::HelloKittyMsgData::LoginRetType_IsValid(value));
  set_has_loginret();
  loginret_ = value;
}

// -------------------------------------------------------------------

// LoginGateway

// required string account = 1;
inline bool LoginGateway::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginGateway::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginGateway::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginGateway::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& LoginGateway::account() const {
  return *account_;
}
inline void LoginGateway::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginGateway::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void LoginGateway::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginGateway::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* LoginGateway::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginGateway::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .HelloKittyMsgData.UserPlateType usertype = 2;
inline bool LoginGateway::has_usertype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginGateway::set_has_usertype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginGateway::clear_has_usertype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginGateway::clear_usertype() {
  usertype_ = 0;
  clear_has_usertype();
}
inline ::HelloKittyMsgData::UserPlateType LoginGateway::usertype() const {
  return static_cast< ::HelloKittyMsgData::UserPlateType >(usertype_);
}
inline void LoginGateway::set_usertype(::HelloKittyMsgData::UserPlateType value) {
  assert(::HelloKittyMsgData::UserPlateType_IsValid(value));
  set_has_usertype();
  usertype_ = value;
}

// required .HelloKittyMsgData.PhoneType phoneType = 3;
inline bool LoginGateway::has_phonetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginGateway::set_has_phonetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginGateway::clear_has_phonetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginGateway::clear_phonetype() {
  phonetype_ = 0;
  clear_has_phonetype();
}
inline ::HelloKittyMsgData::PhoneType LoginGateway::phonetype() const {
  return static_cast< ::HelloKittyMsgData::PhoneType >(phonetype_);
}
inline void LoginGateway::set_phonetype(::HelloKittyMsgData::PhoneType value) {
  assert(::HelloKittyMsgData::PhoneType_IsValid(value));
  set_has_phonetype();
  phonetype_ = value;
}

// required string phoneUuid = 4;
inline bool LoginGateway::has_phoneuuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginGateway::set_has_phoneuuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginGateway::clear_has_phoneuuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginGateway::clear_phoneuuid() {
  if (phoneuuid_ != &::google::protobuf::internal::kEmptyString) {
    phoneuuid_->clear();
  }
  clear_has_phoneuuid();
}
inline const ::std::string& LoginGateway::phoneuuid() const {
  return *phoneuuid_;
}
inline void LoginGateway::set_phoneuuid(const ::std::string& value) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(value);
}
inline void LoginGateway::set_phoneuuid(const char* value) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(value);
}
inline void LoginGateway::set_phoneuuid(const char* value, size_t size) {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  phoneuuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoginGateway::mutable_phoneuuid() {
  set_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    phoneuuid_ = new ::std::string;
  }
  return phoneuuid_;
}
inline ::std::string* LoginGateway::release_phoneuuid() {
  clear_has_phoneuuid();
  if (phoneuuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = phoneuuid_;
    phoneuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoginGateway::set_allocated_phoneuuid(::std::string* phoneuuid) {
  if (phoneuuid_ != &::google::protobuf::internal::kEmptyString) {
    delete phoneuuid_;
  }
  if (phoneuuid) {
    set_has_phoneuuid();
    phoneuuid_ = phoneuuid;
  } else {
    clear_has_phoneuuid();
    phoneuuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameTime

// required uint64 gameTime = 1;
inline bool GameTime::has_gametime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameTime::set_has_gametime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameTime::clear_has_gametime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameTime::clear_gametime() {
  gametime_ = GOOGLE_ULONGLONG(0);
  clear_has_gametime();
}
inline ::google::protobuf::uint64 GameTime::gametime() const {
  return gametime_;
}
inline void GameTime::set_gametime(::google::protobuf::uint64 value) {
  set_has_gametime();
  gametime_ = value;
}

// -------------------------------------------------------------------

// UserBaseInfo

// required uint64 charId = 1;
inline bool UserBaseInfo::has_charid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserBaseInfo::set_has_charid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserBaseInfo::clear_has_charid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserBaseInfo::clear_charid() {
  charid_ = GOOGLE_ULONGLONG(0);
  clear_has_charid();
}
inline ::google::protobuf::uint64 UserBaseInfo::charid() const {
  return charid_;
}
inline void UserBaseInfo::set_charid(::google::protobuf::uint64 value) {
  set_has_charid();
  charid_ = value;
}

// required string name = 2;
inline bool UserBaseInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserBaseInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserBaseInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserBaseInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserBaseInfo::name() const {
  return *name_;
}
inline void UserBaseInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserBaseInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserBaseInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBaseInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserBaseInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBaseInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .HelloKittyMsgData.SexType sex = 3;
inline bool UserBaseInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserBaseInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserBaseInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserBaseInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::HelloKittyMsgData::SexType UserBaseInfo::sex() const {
  return static_cast< ::HelloKittyMsgData::SexType >(sex_);
}
inline void UserBaseInfo::set_sex(::HelloKittyMsgData::SexType value) {
  assert(::HelloKittyMsgData::SexType_IsValid(value));
  set_has_sex();
  sex_ = value;
}

// required uint32 level = 4;
inline bool UserBaseInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserBaseInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserBaseInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserBaseInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 UserBaseInfo::level() const {
  return level_;
}
inline void UserBaseInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint64 exp = 5;
inline bool UserBaseInfo::has_exp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserBaseInfo::set_has_exp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserBaseInfo::clear_has_exp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserBaseInfo::clear_exp() {
  exp_ = GOOGLE_ULONGLONG(0);
  clear_has_exp();
}
inline ::google::protobuf::uint64 UserBaseInfo::exp() const {
  return exp_;
}
inline void UserBaseInfo::set_exp(::google::protobuf::uint64 value) {
  set_has_exp();
  exp_ = value;
}

// required uint64 gold = 6;
inline bool UserBaseInfo::has_gold() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserBaseInfo::set_has_gold() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserBaseInfo::clear_has_gold() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserBaseInfo::clear_gold() {
  gold_ = GOOGLE_ULONGLONG(0);
  clear_has_gold();
}
inline ::google::protobuf::uint64 UserBaseInfo::gold() const {
  return gold_;
}
inline void UserBaseInfo::set_gold(::google::protobuf::uint64 value) {
  set_has_gold();
  gold_ = value;
}

// required uint64 gem = 7;
inline bool UserBaseInfo::has_gem() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserBaseInfo::set_has_gem() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserBaseInfo::clear_has_gem() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserBaseInfo::clear_gem() {
  gem_ = GOOGLE_ULONGLONG(0);
  clear_has_gem();
}
inline ::google::protobuf::uint64 UserBaseInfo::gem() const {
  return gem_;
}
inline void UserBaseInfo::set_gem(::google::protobuf::uint64 value) {
  set_has_gem();
  gem_ = value;
}

// -------------------------------------------------------------------

// ReturnUserInfo

// required bool hasUser = 1;
inline bool ReturnUserInfo::has_hasuser() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReturnUserInfo::set_has_hasuser() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReturnUserInfo::clear_has_hasuser() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReturnUserInfo::clear_hasuser() {
  hasuser_ = false;
  clear_has_hasuser();
}
inline bool ReturnUserInfo::hasuser() const {
  return hasuser_;
}
inline void ReturnUserInfo::set_hasuser(bool value) {
  set_has_hasuser();
  hasuser_ = value;
}

// required .HelloKittyMsgData.UserBaseInfo userBase = 2;
inline bool ReturnUserInfo::has_userbase() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReturnUserInfo::set_has_userbase() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReturnUserInfo::clear_has_userbase() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReturnUserInfo::clear_userbase() {
  if (userbase_ != NULL) userbase_->::HelloKittyMsgData::UserBaseInfo::Clear();
  clear_has_userbase();
}
inline const ::HelloKittyMsgData::UserBaseInfo& ReturnUserInfo::userbase() const {
  return userbase_ != NULL ? *userbase_ : *default_instance_->userbase_;
}
inline ::HelloKittyMsgData::UserBaseInfo* ReturnUserInfo::mutable_userbase() {
  set_has_userbase();
  if (userbase_ == NULL) userbase_ = new ::HelloKittyMsgData::UserBaseInfo;
  return userbase_;
}
inline ::HelloKittyMsgData::UserBaseInfo* ReturnUserInfo::release_userbase() {
  clear_has_userbase();
  ::HelloKittyMsgData::UserBaseInfo* temp = userbase_;
  userbase_ = NULL;
  return temp;
}
inline void ReturnUserInfo::set_allocated_userbase(::HelloKittyMsgData::UserBaseInfo* userbase) {
  delete userbase_;
  userbase_ = userbase;
  if (userbase) {
    set_has_userbase();
  } else {
    clear_has_userbase();
  }
}

// -------------------------------------------------------------------

// RequireCreateRole

// required string name = 1;
inline bool RequireCreateRole::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RequireCreateRole::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RequireCreateRole::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RequireCreateRole::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RequireCreateRole::name() const {
  return *name_;
}
inline void RequireCreateRole::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequireCreateRole::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RequireCreateRole::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RequireCreateRole::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RequireCreateRole::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RequireCreateRole::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .HelloKittyMsgData.SexType sex = 2;
inline bool RequireCreateRole::has_sex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RequireCreateRole::set_has_sex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RequireCreateRole::clear_has_sex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RequireCreateRole::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::HelloKittyMsgData::SexType RequireCreateRole::sex() const {
  return static_cast< ::HelloKittyMsgData::SexType >(sex_);
}
inline void RequireCreateRole::set_sex(::HelloKittyMsgData::SexType value) {
  assert(::HelloKittyMsgData::SexType_IsValid(value));
  set_has_sex();
  sex_ = value;
}

// required uint32 heroId = 3;
inline bool RequireCreateRole::has_heroid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RequireCreateRole::set_has_heroid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RequireCreateRole::clear_has_heroid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RequireCreateRole::clear_heroid() {
  heroid_ = 0u;
  clear_has_heroid();
}
inline ::google::protobuf::uint32 RequireCreateRole::heroid() const {
  return heroid_;
}
inline void RequireCreateRole::set_heroid(::google::protobuf::uint32 value) {
  set_has_heroid();
  heroid_ = value;
}

// -------------------------------------------------------------------

// OpReceiveWorldChatCmd

// required .HelloKittyMsgData.SwitchType switchFlg = 1;
inline bool OpReceiveWorldChatCmd::has_switchflg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OpReceiveWorldChatCmd::set_has_switchflg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OpReceiveWorldChatCmd::clear_has_switchflg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OpReceiveWorldChatCmd::clear_switchflg() {
  switchflg_ = 0;
  clear_has_switchflg();
}
inline ::HelloKittyMsgData::SwitchType OpReceiveWorldChatCmd::switchflg() const {
  return static_cast< ::HelloKittyMsgData::SwitchType >(switchflg_);
}
inline void OpReceiveWorldChatCmd::set_switchflg(::HelloKittyMsgData::SwitchType value) {
  assert(::HelloKittyMsgData::SwitchType_IsValid(value));
  set_has_switchflg();
  switchflg_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace HelloKittyMsgData

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::PhoneType>() {
  return ::HelloKittyMsgData::PhoneType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::NetType>() {
  return ::HelloKittyMsgData::NetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::UserPlateType>() {
  return ::HelloKittyMsgData::UserPlateType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::LoginFailReason>() {
  return ::HelloKittyMsgData::LoginFailReason_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::LoginRetType>() {
  return ::HelloKittyMsgData::LoginRetType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::SexType>() {
  return ::HelloKittyMsgData::SexType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::HelloKittyMsgData::SwitchType>() {
  return ::HelloKittyMsgData::SwitchType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_login_2eproto__INCLUDED
